{"/Expressjs/express-application":{"title":"Express Application","data":{"บทนำ#บทนำ":"app เป็นคำที่เราใช้เพื่อบอกว่า สิ่งนี้ เป็น แอปพลิเคชั่นของ Express\nเราจะสร้างโดยเรียกใช้ฟังก์ชัน express() เป็นคำสั่งแรกๆ ของโมดูล Express นั้น ตามตัวอย่าง ดังนี้:คำสั่งที่ใช้งาน:\nconst express = require(\"express\");\nconst app = express();\napp.get(\"/\", (req, res) => {\n  res.send(\"hello world\");\n});\napp.listen(8000);\nใน object app จะมี method สำหรับทำงานต่างๆ ดังนี้:\nRouting HTTP request; ดูเพิ่มในหัวข้อ app.METHOD และ app.param\nConfigurating middleware; ดูเพิ่มในหัวข้อ app.route\nRendering HTML views; ดูเพิ่มในหัวข้อ app.render\nRegistering a template engine; ดูเพิ่มในหัวข้อ app.engine\nและสามารถตั้งค่าต่างๆ เพื่อกำหนดคุณสมบัติการทำงานของ application นั้นๆ ได้ที่ app.set\nความรู้เพิ่มเติม\nExpress application สามารถอ้างอิงจาก request object และ response objectโดยมีรูปแบบการเขียน คือ req.app และ res.app","คุณสมบัติ-properties#คุณสมบัติ (Properties)":"","applocals#app.locals":"ออปเจก app.locals จะมีคุณสมบัติเป็นตัวแปรแบบ local ใน application นั้น และสามารถใช้ในการเรนเดอร์เทมเพลตได้ ด้วยการใช้ res.render\nconsole.dir(app.locals.title);\n// => 'My App'\nconsole.dir(app.locals.email);\n// => 'my@myapp.com'\nเมื่อเราตั้งค่า app.locals แล้ว ค่านี้จะคงอยู่ตลอดการทำงานของแอปพลิเคชั่น ซึ่งแตกต่างจาก res.locals ที่คงอยู่เฉพาะช่วงเวลาที่ request ทำงานเท่านั้นเราสามารถเข้าถึง local variables ในเทมเพลตที่ถูกเรนเดอร์ภายในแอปพลิเคชั่นได้ นี่คือประโยชน์ของการใช้ helper function สำหรับเทมเพลต ตัว local variable นี้สามารถทำงานได้ใน middleware ผ่านการใช้ req.app.locals (ดูเพิ่มเติมที่ req.app\napp.locals.title = \"My App\";\napp.locals.strflife = require(\"strftime\");\napp.locals.email = \"me@myapp.com\";","appmountpath#app.mountpath":"ออปเจก app.mountpathจะเป็นตัวเก็บ รูปแบบของ path หนึ่งรูปแบบหรือมากกว่า ซึ่งจะใช้กับ sub-app ที่ถูก mounted\nconst express = require(\"express\");\nconst app = express(); // the main app\nconst admin = express(); // the sub app\nadmin.get(\"/\", (req, res) => {\n  console.log(admin.mountpath); // /admin\n  res.send(\"Admin Homepage\");\n});\napp.use(\"/admin\", main); // mount the sub app\nเมื่อเราตั้งค่า app.locals แล้ว ค่านี้จะคงอยู่ตลอดการทำงานของแอปพลิเคชั่น ซึ่งแตกต่างจาก res.locals ที่คงอยู่เฉพาะช่วงเวลาที่ request ทำงานเท่านั้นเราสามารถเข้าถึง local variables ในเทมเพลตที่ถูกเรนเดอร์ภายในแอปพลิเคชั่นได้ นี่คือประโยชน์ของการใช้ helper function สำหรับเทมเพลต ตัว local variable นี้สามารถทำงานได้ใน middleware ผ่านการใช้ req.app.locals (ดูเพิ่มเติมที่ req.app\napp.locals.title = \"My App\";\napp.locals.strflife = require(\"strftime\");\napp.locals.email = \"me@myapp.com\";\nIt is similar to the baseUrl property of the req object, except req.baseUrl returns the matched URL path, instead of the matched patterns.If a sub-app is mounted on multiple path patterns, app.mountpath returns the list of patterns it is mounted on, as shown in the following example.\nconst admin = express();\nadmin.get(\"/\", (req, res) => {\n  console.log(admin.mountpath); // [ '/adm*n', '/manager' ]\n  res.send(\"Admin Homepage\");\n});\nconst secret = express();\nsecret.get(\"/\", (req, res) => {\n  console.log(secret.mountpath); // /secr*t\n  res.send(\"Admin Secret\");\n});\nadmin.use(\"/secr*t\", secret); // load the 'secret' router on '/secr*t', on the 'admin' sub app\napp.use([\"/adm*n\", \"/manager\"], admin); // load the 'admin' router on '/adm*n' and '/manager', on the parent app\nReference: Express Application"}},"/Expressjs/express":{"title":"Express","data":{"":"สวัสดีครับ นี่คือ หน้าหลักของ Express.js ในเว็บของเราExpress.js เป็น Framework ที่ทำให้การพัฒนาแอปพลิเคชั่นบน NodeJS ง่ายขึ้นมาก ทั้งการสร้างเว็บแอปพลิเคชั่นและ APIs\nและยังช่วยจัดการ routes, requests และ responses มี Middlewares ให้เลือกหลายตัว มีความยืดหยุ่น มีความสามารถในการขยายขนาดและน้ำหนักเบาตัวอย่างการใช้งานของ Express.js มีดังนี้\nสามารถเขียน Routes ซึ่งเป็น HTTP Methods ได้ใน URL ที่แตกต่างกัน\nเป็น Middlewares ซึ่งทำหน้าที่เข้าถึง Object ของ Request, Response และ next function ของ clients ที่ส่งข้อมูลมาหาเราได้\nเป็น View engine ที่ใช้ Template Engines หรือ Rendering Data เช่น static template file บนหน้า HTML ซึ่งทำให้ง่ายต่อการดูแลรักษา\nซึ่งเราจะเรียนรู้วิธีการใช้งานกันในบทต่อไป"}},"/Expressjs/getting-started":{"title":"การสร้าง server ด้วย Express.js","data":{"บทนำ#บทนำ":"ในบทนี้ เป็นพื้นฐานในการเขียนแอปด้วย Express ซึ่งประกอบด้วย การจัดเตรียม environment โดย ติดตั้งโมดูลต่างๆ การสร้างแอปพลิเคชัน การเรียกใช้เว็บเซิร์ฟเวอร์ และการสื่อสารพื้นฐานกับเซิร์ฟเวอร์ความรู้ที่ใช้ในขั้นตอนนี้ คือ\nการใช้งานโปรแกรม Node Package Manager พื้นฐาน\nความรู้พื้นฐานในการติดตั้ง dependencies และโมดูล ติดตั้งโมดูลต่างๆ\nความรู้พื้นฐานเกี่ยวกับวิธีการทำงานของเว็บแอปพลิเคชัน\nความรู้เกี่ยวกับ ES6","ขั้นตอนการทำงาน#ขั้นตอนการทำงาน":"","ขั้นตอนที่-1-สร้าง-server-แอปพลิเคชั่นด้วย-nodejs#ขั้นตอนที่ 1 สร้าง server แอปพลิเคชั่นด้วย nodejs":"เพราะว่า express.js ทำงานใน nodejs เราจึงต้องติดตั้ง nodejs แอปพลิเคชั่นตามคำสั่งด้านล่างก่อน\nคำสั่งที่ใช้งาน:\nnpm init\nในการใช้คำสั่งนี้ เราจะต้องตอบคำถามที่ระบบถามเพื่อตั้งค่า project ของเรา และเราสามารถเปลี่ยนแปลงค่าหลังจากนี้ได้ในไฟล์ package.json\nความรู้เพิ่มเติม:หากเราต้องการติดตั้งโดยใช้ค่าเริ่มต้นของระบบทั้งหมด เราสามารถใช้คำสั่ง npm init -y ได้","ขั้นตอนที่-2-ติดตั้ง-express-สำหรับแอปพลิเคชั่นของเรา#ขั้นตอนที่ 2 ติดตั้ง express สำหรับแอปพลิเคชั่นของเรา":"คำสั่งที่ใช้งาน:\nnpm install express\nหากการติดตั้งสำเร็จจะแสดงผลคล้ายภาพนี้","ขั้นตอนที่-3-ตรวจสอบโครงสร้างไฟล์ของโปรเจก#ขั้นตอนที่ 3 ตรวจสอบโครงสร้างไฟล์ของโปรเจก":"โครงสร้างไฟล์ในโปรเจกของเราจะมีหน้าตาคล้ายในภาพ\nเราจะสร้างไฟล์ index.js (ตามค่าเริ่มต้นที่แสดงในไฟล์ package.json คือ \"main\":\"index.js\")\nเพื่อเขียนโค้ดทั้งหมดที่ใช้งานในบทนี้ลำดับการทำงานในไฟล์ idex.js\nเราจะนำเข้า express มาทำงานในไฟล์นี้ ด้วยคำสั่ง require\nสร้างตัวแปร app เพื่อใช้ในการเรียกฟังก์ชัน express() ใน express framework มาทำงาน\nตั้งค่า port เป็น 8000 สำหรับการทำงานแบบ local\nใช้ callback function เพื่อรับค่าการทำงานของ sever ว่า start server สำเร็จ หรือ error\nนำมาเขียนเป็นโค้ดได้ ดังนี้\nconst express = require('express');\nconst app = express();\nconst PORT = 3000;\napp.listen(PORT, (error) =>{\n\tif(!error)\n\t\tconsole.log(\"Server is Successfully Running,\n\t\t\t\tand App is listening on port \"+ PORT)\n\telse\n\t\tconsole.log(\"Error occurred, server can't start\", error);\n\t}\n);","ขั้นตอนที่-4-ทดสอบการทำงาน#ขั้นตอนที่ 4 ทดสอบการทำงาน":"เมื่อเราสร้าง server เสร็จแล้ว เราจะสั่งให้ server ทำงานด้วยคำสั่งต่อไปนี้\nคำสั่งที่ใช้งาน:\nnode index.js\nจะได้ผลการทำงานออกมาดังนี้ตอนนี้ เราสามารถสร้างและสั่งให้ server ทำงานได้สำเร็จแล้ว\nถ้า server ไม่ทำงาน แสดงว่าเกิด error ขึ้น ให้อ่าน error ที่แสดงขึ้นมา วิเคราะห์หาสาเหตุ และแก้ปัญหาที่เกี่ยวข้อง\nหลังจาก server ทำงานได้สำเร็จ หากเราเปิด browser ด้วย url (localhost:8000) มันจะแสดง cannot GET/ เพราะว่าเรายังไม่ได้กำหนดเส้นทาง route ให้กับแอปพลิเคชั่นนี้","ขั้นตอนที่-5-กำหนด-route#ขั้นตอนที่ 5 กำหนด Route":"route คือ endpoint หรือ ปลายทาง ที่กำหนดให้ sever เข้าไปทำงาน\nซึ่งเราจะกำหนดไว้ในส่วนของ backend\nพูดง่าย ๆ คือ route เหมือนเป็นฟังก์ชันหนึ่งในการเรียกใช้ โดยจะเรียกใช้ด้วย request พร้อมส่งเส้นทางที่กำหนดไว้เฉพาะ และได้รับค่าที่ต้องการกลับมาเรา เรียกว่า responseเราสามารถสร้าง routes สำหรับ HTTP method ได้ เช่น get post put delete เป็นต้นตัวอย่าง syntax ของ routes จะมีรูปแบบ ดังนี้\nsyntax:\napp.anyMethod(path, function)\nเราจะนำมาเขียนเป็น code ได้เป็น:\napp.get(\"/\", (req, res) => {\n  res.send(\"hello world\");\n});\nนำมาใส่ใน index.js ได้ ดังนี้\nconst express = require('express');\nconst app = express();\nconst PORT = 3000;\napp.get('/', (req,res)=>{\n    res.send('hello world')\n})\napp.listen(PORT, (error) =>{\n\tif(!error)\n\t\tconsole.log(\"Server is Successfully Running,\n\t\t\t\tand App is listening on port \"+ PORT)\n\telse\n\t\tconsole.log(\"Error occurred, server can't start\", error);\n\t}\n);\nจะได้ผลการทำงานออกมาดังนี้มาถึงจุดนี้ เราสามารถสร้าง server ด้วย express สามารถ run server ได้ และเรียกใช้งาน get method จาก browser ได้\nRefernce: geeksforgeeks"}},"/Next.js/00-01-Installation":{"title":"00-01 การติดตั้ง Next.js (Installation)","data":{"":"ความต้องการของระบบ:\nNode.js 16.14 ขึ้นไป\nmacOS หรือ Windows(ที่ติดตั้ง WSL) หรือ Linux","การติดตั้งแบบอัตโนมัติ#การติดตั้งแบบอัตโนมัติ":"เราแนะนำให้เริ่มต้นแอพใหม่ของ Next.js ด้วย คำสั่ง create-next-app\nซึ่งจะติดตั้งทุกอย่างให้เราโดยอัตโนมัติ เรามาดูตัวอย่างการสร้างโปรเจคกัน\nnpx create-next-app@latest\nในขั้นตอนการติดตั้งระบบจะถามเราดังนี้\nWhat is your project named? my-app\nWould you like to use TypeScript? No / Yes\nWould you like to use ESLint? No / Yes\nWould you like to use Tailwind CSS? No / Yes\nWould you like to use `src/` directory? No / Yes\nWould you like to use App Router? (recommended) No / Yes\nWould you like to customize the default import alias (@/*)? No / Yes\nWhat import alias would you like configured? @/*\nหลังจากตอบคำำถามในขั้นตอนนี้เสร็จแล้ว create-next-app จะสร้าง folder เป็นชื่อโปรเจคของเรา และติดตั้งส่วนประกอบต่างๆให้เรา\nสาระน่ารู้\nตอนนี้ Next.js มาพร้อมกับ TypeScript ESLint และ Tailwind CSS ซึ่งจะตั้งเป็นค่าเริ่มต้น\nเราสามารถเลือกให้มีโฟลเดอร์ src ใน root ของโปรเจคเพื่อแยกโค้ดของเราออกจากไฟล์ที่ตั้งค่าระบบ Next.js","run-the-development-server#Run the Development Server":"ใช้คำสั่ง npm run dev เพื่อสั่งให้ sever ในส่วนของ development ที่ทำงาน\nเข้าไปที่ http://localhost:3000 เพื่อดูแอพของคุณ\nแก้ไขไฟล์ app/layout.tsx หรือ page.tsx แล้ว save เพื่อดูผลการเปลี่ยนแปลงใน browser ของคุณ","ขั้นต่อไป#ขั้นต่อไป":"เรียนรู้เกี่ยวกับโครงสร้างของไฟล์และโฟลเดอร์ในโปรเจค Next.js ของคุณ\nแปลและเรียบเรียงโดย ModTdinOriginal: Installation\n00-00-getting-startedHome00-02-Project-Structure"}},"/Next.js/00-02-Project-Structure":{"title":"00-02 โครงสร้างไฟล์และโฟลเดอร์ใน Next.js (Next.js Project Structure)","data":{"":"ในส่วนนี้จะเรียนรู้เกี่ยวกับโครงสร้างไฟล์และโฟลเดอร์ของโปรเจค Next.js ซึ่งจะครอบคลุม top-level ไฟล์และโฟลเดอร์ configuration files และ routing conventions ใน app directory","top-level-folders#Top-level folders":"app\nApp Router\npages\nPages Router\npublic\nStatic assets to be served\nsrc\nOptional application source folder","top-level-files#Top-level files":"Next.js\nnext.config.js\nไฟล์ configuration สำหรับ Next.js\ninstrumentation.ts\nไฟล์ OpenTelemetry และ Instrumentation\nmiddleware.ts\nสำหรับ Next.js ใช้เรียก middleware\n.env\nไฟล์เก็บตัวแปร Environment\n.env.local\nไฟล์เก็บตัวแปร Local Environment\n.env.production\nไฟล์เก็บตัวแปร Environment สำหรับ Production\n.env.development\nไฟล์เก็บตัวแปร Environment สำหรับ development\n.eslintrc.json\nไฟล์เก็บ Configuration สำหรับ ESLint\n.gitignore\nไฟล์สำหรับเก็บรายชื่อไฟล์และโฟลเดอร์ที่ไม่ต้องการให้โหลดขึ้น Git\nnext-env.d.ts\nไฟล์สำหรับประกาศชนิดตัวแปร TypeScript สำหรับ Next.js\ntsconfig.json\nไฟล์ Configuration สำหรับ TypeScript\njsconfig.json\nไฟล์ Configuration สำหรับ JavaScript","app-routing-conventions#app Routing Conventions":"","routing-files#Routing Files":"layout\n.js .jsx .tsx\nLayout\npage\n.js .jsx .tsx\nPage\nloading\n.js .jsx .tsx\nLoading UI\nnot-found\n.js .jsx .tsx\nNot found UI\nerror\n.js .jsx .tsx\nError UI\nglobal-error\n.js .jsx .tsx\nGlobal error UI\nroute\n.js .ts\nAPI endpoint\ntemplate\n.js .jsx .tsx\nRe-rendered layout\ndefault\n.js .jsx .tsx\nParallel route fallback page","nested-routes#Nested Routes":"folder\nRout segment\nfolder/folders\nNested rout segment","dynamic-routes#Dynamic Routes":"[folder]\nDynamic route segment\n[...folder]\nCatch-all route segment\n[[...folder]]\nOptional catch-all route segment","routes-groups-และ-private-folders#Routes Groups และ Private Folders":"(folder)\nสร้างโฟลเดอร์แบบนี้สำหรับจัดกลุ่ม route โดยไม่มีผลกับการใช้ routing\n_folder\nโฟลเดอร์นี้และ child ทั้งหมด จะไม่อยู่ใน routing","parallel-และ-intercepted-routes#Parallel และ Intercepted Routes":"@folder\nชื่อ slot\n(.)folder\nIntercept ในระดับเดียวกัน\n(..)folder\nIntercept ในระดับที่สูงขึ้นไปหนึ่งระดับ\n(..)(..)folder\nIntercept ในระดับที่สูงขึ้นไปสองระดับ\n(...)folder\nIntercept จาก root","การตั้งชื่อของ-meta-file#การตั้งชื่อของ Meta file":"","app-icons#App Icons":"favicon\n.ico\nไฟล์ Favicon\nicon\n.ico .jpg .jpeg .png .svg\nไฟล์ App icon\nicon\n.js .ts .tsx\nไฟล์สร้าง App icon\napple-icon\n.jpg .jpeg .png\nไฟล์ Apple App icon\napple-icon\n.js .ts .tsx\nไฟล์สร้าง Apple App icon","open-graph-และ-twitter-images#Open Graph และ Twitter Images":"opengraph-image\n.jpg .jpeg .png .gif\nไฟล์ Open Graph image\nopengraph-image\n.js .ts .tsx\nไฟล์สร้าง Open Graph image\ntwitter-image\n.jpg .jpeg .png .gif\nไฟล์ Twitter image\ntwitter-image\n.js .ts .tsx\nไฟล์สร้าง Twitter image","seo#SEO":"sitemap\n.xml\nไฟล์ sitemap\nsitemap\n.js .ts\nไฟล์สร้าง sitemap\nrobots\n.txt\nไฟล์ robots\nrobots\n.js .ts\nไฟล์สร้าง robots\nแปลและเรียบเรียงโดย ModTdinOriginal: Next.js Project Structure\n00-01-InstallationHome01-00-App-Router"}},"/Next.js/01-Routing/01-00-App-Router":{"title":"01-00 App Router","data":{"":"App Router ของ Next.js เป็นแนวคิดใหม่ในการสร้างแอพพลิเคชั่นโดยใช้คุณสมบัติล่าสุดของ React\nถ้าคุณเคยใช้ Next.js มาแล้ว คุณจะพบว่า App Router เป็นการเปลี่ยนแปลงที่เป็นธรรมชาติของ ระบบไฟล์ที่มีอยู่บนพื้นฐาน router ใน Pages Routerสำหรับการสร้างแอพพลิเคชั่นใหม่ๆ ทาง Next.js แนะนำให้ใช้ App Router สำหรับแอพพลิเคชั่นที่เปิดใช้อยู่แล้ว คุณสามารถค่อยๆปรับใช้ App Router เพิ่มเข้าไป เพราะว่า router ทั้งสองแบบสามารถใช้ร่วมกันในแอพพลิเคชั่นเดียวกันได้","คำถามที่พบบ่อย#คำถามที่พบบ่อย":"","เราจะเข้าถึงการ-request-object-ใน-layout-ได้อย่างไร#เราจะเข้าถึงการ request object ใน layout ได้อย่างไร":"โดยปกติเราจะไม่สามารถเข้าถึง raw request object แต่อย่างไรก็ตาม เราสามารถเข้าถึง headers และ cookies ผ่าน function ของ server-only ได้ และเราก็สามารถตั้งค่า cookies ได้Layout ไม่สามารถเป้นตัว renderer ได้ พวกมันถูก cache และ ใช้ซ้ำโดยไม่จำเป็นต้องมีการคำนวณใหม่ตอนที่มีการเปลี่ยนหน้าเพจ ด้วยการถูกจำกัดจาก layout จากการเข้าถึง raw request นี้ Next.js สามารถป้องกันไม่ให้เกิดการทำงานที่ช้าหรือการใช้โค้ดที่เกินความจำเป็นของ layout ที่ทำให้ประสิทธิภาพลดลงการออกแบบนี้จะทำการวาง layout เป็นระบบ ดูง่ายในการพัฒนาและการแก้ไขข้อผิดพลาดต่างๆที่เกิดขึ้น เพราะว่ามีรูปแบบที่เป็นระบบเหมือนๆกันในแต่ละหน้าในการออกแบบ UI ตัว Parallel Route จะทำให้เราสามารถ render หลายๆหน้าได้พร้อมมกัน และการเข้าถึง route segment ทำได้โดย URL search params","เราจะเข้าถึงการ-url-บน-page-ได้อย่างไร#เราจะเข้าถึงการ URL บน page ได้อย่างไร":"Next.js ตั้งค่าเริ่มต้นของเพจให้เป้น Server Component เราสามารถเข้าถึงผ่าน route segment ผ่าน params prop และ URL search params ผ่าน searchParams prop ของแต่ละเพจแต่ถ้าเราจะใช้ Client Component เราจะให้ usePathname useSelectedLayoutSegment และ useSelectedLayoutSegments สำหรับ route ที่ซับซ้อนในการออกแบบ UI ตัว Parallel Route จะทำให้เราสามารถ render หลายๆหน้าได้พร้อมมกัน และการเข้าถึง route segment ทำได้โดย URL search params","เราจะ-redirect-จาก-server-component-ได้อย่างไร#เราจะ redirect จาก Server Component ได้อย่างไร":"เราสามารถใช้ redirect เพื่อเปลี่ยนเส้นทางจากหน้าที่เราอยู่ได้ทั้ง URL แบบ relative หรือ แบบ absolute\nredirect สามารถทำได้ทั้ง temporary(307) redirect หรือ permanentRedirect ซึ่่งเป็น permanent(308) redirect\nฟังก์ชันเหล่านี้จะถูกใช้เมื่อเป็น streaming UI ซึ่งจะมี meta tag ในการทำ redirect บน client side","เราจะทำการ-authentication-บน-app-router-ได้อย่างไร#เราจะทำการ authentication บน App Router ได้อย่างไร":"นี่คือวิธีการโดยทั่วไปที่จะทำให้เราสามารถทำ authentigation ใน App Router ได้\nNextAuth.js\nClerk\nAuth0\nStytch\nหรือการโดยใช้การ handlin sessions เอง หรือ JWTs","เราจะ-ตั้งค่า-cookies-ได้อย่างไร#เราจะ ตั้งค่า cookies ได้อย่างไร":"เราสามารถใช้ cookie ใน Server Action หรือ Route Handlers โดยใช้ cookies functionแต่สำหรับ HTTP เราไม่สามารถใช้ cookies หลังจาก streaming ได้ เราไม่สามารถใช้ cookies จากเพจหรือ layout ได้โดยตรง เราจึงต้องใช้ผ่าน Middleware","เราจะสร้าง-multi-tenant-apps-ได้อย่างไร#เราจะสร้าง multi-tenant apps ได้อย่างไร":"ถ้าคุณกำลังหา application เดี่ยวๆจาก Next.js ที่รองรับ multi tenants ได้ ทาง Next.js ก็มีตัวอย่างให้ดู","เราจะทำงานกับ-cache-ใน-app-router-ได้อย่างไร#เราจะทำงานกับ cache ใน App Router ได้อย่างไร":"caching ใน Next.js มีหลายชั้น ดังนั้นจึงหลายแนวทางในการจัดการ ซึ่งเราจะต้องเรียนรู้ต่อไป","มี-open-source-application-ที่มีเนื้อหาสำหรับ-app-router-บ้างไหม#มี Open-source application ที่มีเนื้อหาสำหรับ App Router บ้างไหม":"เราสามารถดูได้จาก Next.js Commerce หรือ Platform Starter Kit","หัวข้อที่เราจะต้องเรียนรู้ในการสร้างแอพพลิเคชันโดย-nextjs-app-router-มี-9-หัวข้อ-ดังนี้#หัวข้อที่เราจะต้องเรียนรู้ในการสร้างแอพพลิเคชันโดย Next.js App router มี 9 หัวข้อ ดังนี้":"Routing fundamentals\nData Fetching\nRendering\nCaching\nStyling\nOptimizing\nConfiguring\nDeploying\nUpgrading\nแปลและเรียบเรียงโดย ModTdinOriginal: App Router\n00-02-Project-StructureHome01-01-Routing-Fundamentals"}},"/Next.js/01-Routing/01-01-Routing-Fundamentals":{"title":"01-01 Routing Fundamentals","data":{"":"ในทุกๆแอพพลิเคชั่นจะมี routing เป็นโครงสร้างหลัก เนื้อหาในบทนี้จะกล่าวถึงความรู้พื้นฐานเรื่อง routing ของ web และ การทำงานกับ routing ใน Next.js","คำศัพท์พื้นฐาน#คำศัพท์พื้นฐาน":"อันดับแรกเราจะเรียนรู้เกี่ยวกับคำศัพท์ที่เกี่ยวข้อง ตามที่แสดงในรูปภาพต่อไปนี้\nTree: คือ การแสดงโครงสร้างของเว็บโดยเปรียบเทียบกับส่วนต่างๆของต้นไม้ เช่น root(ราก) leave(ใบ)เป็นต้น ตัวอย่างเช่น component tree ประกอบด้วย component ที่เป็น parent และ children นอกจากนั้นยังแสดงให้เห็นถึง โครงสร้างของ file และ folder ในแอพลิเคชั่นอีกด้วย\nSubtree: คือ ส่วนหนึ่งของ tree โดยเริ่มจาก จุดเริ่มต้นที่เรากำหนดจะเรียกว่า new root(รากใหม่) ของ subtree นั้น และสิ้นสุดที่ leave(ส่วนใบ)\nRoot: คือจุดแรก(first node) ของ tree หรือ subtree เช่น root layout\nLeaf: เป็นส่วนหนึ่งของ subtree ที่ไม่มี chrildren มักจะเป็นส่วนสุดท้ายของ URL path\nURL Segment: คือส่วนของ URL path จะปิดท้ายด้วยเครื่องหมาย slashes\nURL Path: คือส่วนของ URL path ที่ต่อจาก Domain(ประกอบขึ้นจาก URL segment)","the-app-router#The app Router":"ในเวอร์ชั่น 13 ของ Next.js ได้มีการสร้างชิ้้นส่วนใหม่ขึ้นมาใช้งานบน React Server Components ที่เรียกว่า App Router\nซึ่ง App Router นี้จะรองรับการทำงานใหม่ ดังนี้\nการใช้ layout ร่วมกัน (Shared layout)\nการนำ routing มาซ้อนกัน (Nested routing)\nการแสดงผลระหว่างการรอโหลด (loading states)\nการจัดการกับ error (Error handling)\nและอื่นๆ\nการทำงานของ App Router นี้จะทำงานภายใต้ไดเรกทอรีที่ชื่อว่า app\nในส่วนของไดเรกทอรี่ app นี้ สามารถทำงานคู่ไปกับไดเรกทอรี pages ที่มีอยู่เดิมได้ ซึ่งจะเป็นการเพิ่มทางเลือกในการจัดการ route ของแอพพลิเคชั่นเดิมของเราให้มีความสามารถในการทำงานกับ route มากขึ้น (ถ้าคุณใช้ Pages directory ในแอพพลิชันของคุณ ให้ดูคู่มือของ Pages Router ซึ่งอยู่นอกเหนือจากคู่มือนี้)\nสิ่งที่ควรรู้: ใน Next.js จะจัดลำดับความสำคัญของ App Router ให้มาก่อน Page Router เสมอ\nหากมี Routes ข้ามไดเรกทอรีจะไม่สามารถทำงานใน URL Path เดียวกัน และจะส่งผลให้เกิด error เมื่อถูกเรียกใช้งาน\nค่าเริ่มต้นของ components ที่อยู่ใน app จะทำงานบน React Server Component ซึ่งจะทำให้เกิดประสิทธิภาพที่ดี และทำให้ง่ายต่อการนำไปใช้ (หากคุณต้องการทำงานบน Client Components คุณสามารถดูได้ในหัวข้อ Client Component)\nหากคุณยังใหม่กับการใช้ Server Component แนะนำให้อ่านในหัวข้อ Server Components","หน้าที่ของ-folders-และ-files#หน้าที่ของ Folders และ Files":"ใน App Router Next.js จะใช้ Folders และ Files ในการกำหนด route\nดังนี้\nFolders จะใช้ในการกำหนด routes โดยใช้ลำดับการซ้อนกันของ Folder\nเป็นเส้นทางของหน้าเพจที่ใช้แสดงผล ซึ่งจะเรียงตามลำดับ เริ่มตั้งแต่ Folder ชั้นนอกสุด(root\nfolder)ไปจนถึงโฟลเดอร์ที่อยู่ในสุด(leaf folder) ซึ่งจะเก็บไฟล์ page.js อยู่ข้างใน\n(ดูเพิ่มเติมในหัวข้อ Defining Routes)\nFiles จะเป็นส่วนที่ใช้เก็บโค้ดสำหรับสร้าง\nUI ที่จะแสดงผลสำหรับ rout segment นั้น (ดูเพิ่มเติมในหัวข้อ special files)","route-segments#Route segments":"folder หนึ่งชั้นใน route นั้น จะทำหน้าที่เป็นหนึ่งตัวของ route segment ซึ่งเมื่อประกอบกันโดยเรียง route segment ตั้งแต่ต้นจนครบทุกตัวในเส้นทางนั้นก็จะเป็น\nURL Path","การสร้าง-nested-routes-nested-routes#การสร้าง Nested Routes (Nested Routes)":"ในการสร้าง Nested Routes เราทำได้โดยสร้างโฟลเดอร์ขึ้นมาในโฟล์เดอร์ชั้นที่สูงกว่า เช่น เราจะสร้าง route ที่มีรูปแบบ /dashboard/settings โดยสร้าง folder ชื่อ dashboard ให้อยู่ใน folder ชื่อ app และ สร้าง Folder ชื่อ settings ให้อยู่ใน Folder ชื่อ dashboard อีกทีหนึ่งสรุป /dshboard/settings มีส่วนประกอบ 3 segments คือ\n/ (Root segment)\ndashboard (Segment)\nsettings (Leaf segment)","การตั้งชื่อไฟล์-file-conventions#การตั้งชื่อไฟล์ (File Conventions)":"ใน Next.js จะมีไฟล์พิเศษสำหรับการสร้าง UI ซึ่งจะมีลักษณะเฉพาะ ดังนี้\nlayout\nทำหน้าที่ shared UI สำหรับ segment และ children ของมัน\npage\nทำหน้าที่เป็น UI ของ route นั้น และทำให้ route นั้นแสดงผลได้\nloading\nทำหน้าที่เป็น UI ในการ loading ของ segment และ children ของมัน\nnot-found\nทำหน้าที่เป็น UI เมื่อเกิด Not found ของ segment และ children ของมัน\nerror\nทำหน้าที่เป็น UI เมื่อเกิด Error ของ segment และ children ของมัน\nglobal-error\nทำหน้าที่เป็น UI เมื่อเกิด Global Error\nroute\nทำหน้าที่เป็น endpoint ของ Server-side\ntemplate\nเป็น UI layout พิเศษในการ re-rendered\ndefault\nเป็น Fallback UI ของ Parallel Routes\nข้อควรรู้: ไฟล์พิเศษเหล่านี้ แต่ละไฟล์สามารถมีนามสกุลเป็น .js .jsx .tsx อย่างใดอย่างหนึ่งก็ได้","ผัง-component-component-hierachy#ผัง Component (Component Hierachy)":"ในการสร้างไฟล์พิเศษสำหรับ React Component จะมีการ render ตามลำดับ ดังนี้:\nlayout.js\ntemplate.js\nerror.js (React error boundary)\nloading.js (React suspense boundary)\nnot-found.js (React error boundary)\npage.js หรือ nested layout.js\nในการใช้ route แบบซ้อนกัน Component segment(สีม่วงในรูปด้านล่าง) จะซ้อนอยู่ข้างในของ parent segment(สีฟ้าในรูป)","colocation#Colocation":"เราสามารถสร้างไฟล์พิเศษเพิ่มเติมลงไปในโฟลเดอร์ต่างๆในไดเรกทอรี app ของเราเพื่อเพิ่มคุณลักษณะพิเศษได้ เราจะเรียกวิธีการนี้ว่าการทำ colocation (เช่น ไฟล์ components ไฟล์ styles ไฟล์ tests และอื่นๆ)ที่เป็นอย่างนี้เพราะว่า Next.js ใช้ folder ในการกำหนด routes และแสดงเฉพาะข้อมูลในไฟล์ page.js หรือ route.js เท่านั้น","วิธีการกำหนด-route-ขั้นสูงadvance-routing-patterns#วิธีการกำหนด Route ขั้นสูง(Advance Routing Patterns)":"ใน App Router เรามีเครื่องมือที่ช่วยในการทำงานสำหรับรูปแบบการจัดการ route ขั้นสูง ประกอบด้วย\nParallel Routes: ทำให้เราแสดงสองหน้าหรือมากกว่าใน view เดียวกันได้ และสามารถนำทางของแต่ละหน้าได้ เราสามารถใช้มันแบ่งหน้าจอแสดงผลทำให้มีการนำทางของแต่ละเพจได้ เช่น Dashboards\nIntercepting Routes: ทำให้เรา intercept a route และแสดงมันให้เป็นส่วนหนึ่งของ route อื่น เราสามารถใช้เครื่องมือนี้สำหรับการคงบริบทเดิมไว้สำหรับหน้าปัจจุบัน เช่น เราสามารถดู task ต่างๆ เมื่อเราแก้ไข task หนึ่ง หรือ ขยายรูปใน feed\nเครื่องมือนี้ทำให้เราสร้าง UI ที่ซับซ้อนได้มากขึ้น","next-steps#Next Steps":"และตอนนี้เราเข้าใจเกี่ยวกับความรู้พื้นฐานของ Routing ใน 01-02-Defining-Routes\nแปลและเรียบเรียงโดย ModTdinOriginal: Routing\n01-00-App-RouterHome01-02-Defining-Routes"}},"/Next.js/01-Routing/01-02-Defining-Routes":{"title":"01-02 Defining Routes","data":{"":"เราแนะนำให้ทำความเข้าใจ ความรู้พื้นฐานเกี่ยวกับ Routing ก่อนที่จะเริ่มบทนี้\nบทนี้จะมีเนื้อหาเกี่ยวกับแนวทางการสร้างและจัดการ routes ใน Next.js แอพพลิเคชัน","การสร้าง-route-creating-routes#การสร้าง Route (Creating Routes)":"Next.js ใช้การวางโครงสร้างไฟล์และโฟลเดอร์เป็นตัวกำหนด routesแต่ละโฟลเดอร์จะแทน route segment หนึ่ง segment ซึ่งทำหน้าที่กำหนดเส้นทางให้กับ URLในการสร้าง nested route เราสามารถสร้างโฟลเดอร์ในโฟลเดอร์ได้\nใน Next.js จะใช้ไฟล์พิเศษไฟล์หนึ่ง ชื่อ page.js ทำหน้าที่เก็บโค้ดเพื่อแสดงผลสำหรับแต่ละ route\nตัวอย่าง เช่น URL path /dashboard/analytics จะไม่มีการแสดงผลออกมาเพราะว่าไม่มีไฟล์ page.js ในโฟลเดอร์ analytics\nแต่เราสามารถใช้โฟลเดอร์นี้เก็บ components stylesheet images หรือ colocated file ได้\nข้อควรรู้: นามสกุลของไฟล์พิเศษนี้ สามารถเป็น .js .jsx .tsx อย่างใดอย่างหนึ่งก็ได้","การสร้าง-ui-creating-ui#การสร้าง UI (Creating UI)":"ไฟล์พิเศษที่ได้ถูกกำหนดไว้ จะใช้เพื่อสร้าง UI ของแต่ละ route segment ที่ใช้มากที่สุดคือไฟล์ page เพื่อแสดง UI เพื่อแสดง UI ของ route นั้น และไฟล์ layout ที่ใช้แสดง UI ร่วมกันหลายๆ routesเรามาดูตัวอย่างการสร้างหน้าแรกกัน\nการสร้างหน้าแรกของแอพ เราจะสร้างไฟล์ pages.js ไว้ในไดเรกทอรี app และทำการ export React component ออกมา\n(ในที่นี้จะแสดงเป็น TypeScript)\nexport default function Page() {\n    return <h1>Hello Next.js!<h1/>\n}","next-steps#Next Steps":"ต่อไปเราจะไปเรียนรู้เกี่ยวกับการสร้าง 01-03-Pages-and-Layouts กัน\nแปลและเรียบเรียงโดย ModTdinOriginal: Defining Routes\n01-01-Routing-FundamentalsHome"}},"/Next.js/01-Routing/01-04-Linking-and-Navigating":{"title":"01-04 Linking and Navigating","data":{"":"ในการทำ Navigate ระหว่าง routes ใน Next.js มีอยู่ 2 แนวทาง คือ\nใช้คอมโพแนนท์ <Link>\nใช้ useRouter Hook\nในบทนี้เราจะเรียนรู้เกี่ยวกับการใช้ <Link> useRouter() และลงลึกไปถึงการทำงานของ navigation","link-component#<Link> Component":"<Link> เป็นวิธีพื้นฐานในการนำทางระหว่าง routes ใน Next.js เป็น built-in component ที่ขยายเพิ่มเติมมาจากแท็ก <a> ของ HTML ที่จะทำให้เราทำการ prefetching และ นำทางระหว่าง route ใน client-sideเราสามารถ import จาก next/link และส่งค่าผ่าน href prop ไปให้ component\nimport Link from \"next/link\";\nexport default function Page() {\n  return <Link href=\"/dashboard\">Dashboard</Link>;\n}\nนอกจากนี้ยังมีวิธีอื่นอีกในการส่ง prop ผ่าน <Link>\nลองศึกษาหัวข้อ API reference เพิ่มเติม","examples#Examples":"","linking-to-dynamic-segments#Linking to Dynamic segments":"เมื่อเราจะใช้ link ทำงานกับ Dynamic segment เราสามารถใช้ template literals และ interpolation ในการสร้างรายการของ link ขึ้นมา เรามาดูวิธีการสร้างรายการของ blog post กัน\nimport Link from 'next/link'\nexport default function PostList({posts}){\n    return (\n        <ul>\n            {posts.map((post)=>(\n                <li key={post.id}>\n                    <Link href={`/blog/${post.slug}`>{post.title}</Link>\n                </li>\n            ))}\n        </ul>\n    )\n}","checking-active-links#Checking Active Links":"เราสามารใช้ usePathname() เพื่อหา link ที่กำลังทำงานได้ ตัวอย่างเช่น ถ้าเราจะเพิ่ม class เข้าไปใน link ที่กำลังทำงาน เราจะต้องตรวจสอบว่า link ปัจจุบัน pathname ตรงกันกับ href ที่อ้างถึงหรือไม่\n'use client'\nimport { usePathname } from 'next/navigation'\nimport Link from 'next/link'\nexport function Links(){\n    const pathname = usePathname()\n    return(\n        <nav>\n            <ul>\n                <li>\n                    <Link className={`link ${pathname === '/' ? 'active' : ''}`} href='/>\n                    Home\n                    </Link>\n                </li>\n                <li>\n                    <Link\n                        className={`link ${pathname === 'about' ? 'acive' : ''}`}\n                        href=\"/about\"\n                    >\n                    </Link>\n                </li>\n            </ul>\n        </nav>\n    )\n}","scrolling-to-an-id#Scrolling to an id":"ค่าตั้งต้นใน App Router ของ Next.js จะเป็น scroll to the top ของ new route หรือ อยู่ที่ตำแหน่งเดิมสำหรับ การย้อนกลับ(backward) หรือ การนำทางไปข้างหน้า(forward)ถ้าเราต้องการให้ scroll ไปที่ตำแหน่งของ id ที่ต้องการ เราสามารถต่อท้ายด้วย # เพื่อเชื่อมหรือส่งผ่าน hash link เข้าไปให้ href prop เราสามารถใช้ได้กับ <Link> ในการ render ไปให้ <a> element\n<Link href=\"/dashboard#setting\">Setting</Link>\n// Output\n<a href=\"/dashboard#setting\">Setting</a>","disabling-scrool-restoration#Disabling scrool restoration":"ค่าตั้งต้นของ App Router ใน Next.js คือ scroll to top ของ route ใหม่ หรือ อยู่ที่ตำแหน่งเดิมสำหรับ การย้อนกลับ และ การนำทางไปข้างหน้า\nถ้าเราต้องการตั้งค่าใหม่เราสามารถทำได้โดยตั้งค่า scroll={false} ใน <Link> component หรือ scroll:false ไปให้ router.push() หรือ router.replace()`\n// next/link\n<Link href=\"/dashboard\" scroll={false}>\n  Dashboard\n</Link>\n// useRouter\nimport { useRouter } from \"next/navigation\";\nconst router = useRouter();\nrouter.push(\"/dashboard\", { scroll: false });","userouter-hook#useRouter() Hook":"useRouter hook เป็นคำสั่งที่ทำให้เราสามารถเปลี่ยน routes ได้useRouter นี้ใช้ได้เฉพาะใน use client เท่านั้น และเราต้อง import from next/navigation\napp/page.js\n'use client'\nimport { useRouter } from 'next/navigation'\nexport default funtion Page(){\n    const router = useRouter()\n    return(\n        <button type=\"button\" onClick={()=>router.push('/dashboard')}>\n            Dashboard\n        </button>\n    )\n}\nรายการคำสั่งสำหรับ useRouter ทั้งหมด ดูได้ที่ API reference\nNext.js แนะนำให้ใช้ <Link> ในการนำทางระหว่าง routes จนกว่าจะมีความต้องการเฉพาะที่ต้องใช้ useRouter","how-routing-and-navigation-works#How Routing and Navigation Works":"App Router ของ NExt.js ใช้การผสมกันระหว่า routing และ navigation\nฝั่ง server โค้ดของเราจะถูแแบ่งโดย route-segment และฝั่ง client นั้น Next.js จะทำการ prefetches และ caches ตัว route segment หมายความว่า เมื่อ user navigetes ไปที่ new route ตัว browser จะไม่ทำการ reload page จะมีเฉพาะ route segment เท่านั้นที่ทำการ re-render ใหม่ การทำแบบนี้เพื่อทำให้ navigation experience และ performance ดีขึ้น","1-prefetching#1. Prefetching":"prefetching คือ การ preload ตัว route ในการทำงานแบบเบื้องหลัง ก่อนที่ผู้ใช้จะเข้าไปใช้งานการ Prefetching ใน Next.js มี 2 แนวทาง คือ\n<Link> component: Routes ต่างๆ จะถูก prefetch โดยอัตโนมัติ เตรียมพร้อมเพื่อแสดงผลให้ user ดู จะเกิดขึ้นเมื่อมีการโหลดหน้าขึ้นมาครั้งแรก หรือเมื่อมีการดูผ่าน scroll\n`router.prefetch(): โดยใช้ useRouter ในการสั่ง prefetch routes\nการ prefetchig ของ <Link> จะแตกต่างกันระหว่าง stacic กับ dynamic routes ดังนี้:\nStatic Routes: ค่าของ prefetch คือ true นั่นคือ routes ที่มีอยู่จะถูกทำ prefetched และ cached ไว้\nDynamic Routes: ค่าของ prefetch คือ automatic มีเฉพาะ shared layout ที่ถูกเตรียมไว้ จนกว่า loading.js จะถูก prefetch และจะทำการ cached ไว้ 30 วินาที การทำแบบนี้จะทำให้ลดการ fetching ของ dynamic routes ที่มีอยู่ทั้งหมด หมายความว่า เราสามารถแสดง instant loading state สำหรับแสดงผลให้กับ user\nเราสามารถปิดการ prefetching โดย ตั้งค่าที่ prefetch prop ให้เป็น falseสามารถศึกษาเพิ่มเติมเกี่ยวกับ <Link> ได้ที่ API reference\nความรู้เพิ่มเติม:\nPrefetching จะทำงานเฉพาะ production เท่านี้ จะไม่ทำงานใน development","2-caching#2. Caching":"Next.js มีการใช้ in-memory client-side cached เรียกว่า Router Cache\nเมื่อ user ได้เปิดหน้าต่างๆของ app ตัว React Server Component Payload ของ prefetched route segment และ routes ที่ได้ดูไปแล้วจะถูกเก็บไว้ใน cacheหมายความว่า ในการนำทางไปหน้าต่างๆนั้น Next.js จะนำข้อมูลใน cache มาใช้ใหม่ให้มากที่สุดเท่าที่เป็นไปได้ - การทำแบบนี้จะเป็นการลดจำนวนการ request ไปที่ server ซึ่งเป็นการปรับปรุงประสิทธิภาพโดยการลดจำนวนครั้งของการ request และ การถ่ายโอนข้อมูลดูข้อมูลเพิ่มเติมในหัวข้อ Data Fetching สำหรับการทำงานของ Router Cache และการตั้งค่า","3-partial-rendering#3. Partial Rendering":"Partial Rendering คือการ re-render เฉพาะส่วนที่มีการเปลี่ยนแปลงของ route segment บน client และส่วนที่เป็น shared segment ที่จองไว้เท่านั้นตัวอย่างเช่น เมื่อ มีการนำทางระหว่าง 2 routes ที่อยู่ในระดับเดียวกัน อย่าง /dashboard/setting และ dashboard/analytics ตัว route segment ที่อยู่ในระดับเดียวกัน คือ setting และ analytics ที่จะถูก render และ ใช้ layout ใน dashboard ร่วมกัน\nถ้าไม่มีการ render บางส่วน จะทำให้ต้อง render ใหม่ทั้งหมดบน server\nการ render บางส่วน ทำให้ลดจำนวนการถ่ายโอนข้อมูลและเวลาในการทำงาน ซึ่งหมายถึงการทำให้แอพมีประสิทธิภาพมากขึ้น","4-soft-navigation#4. Soft Navigation":"โดยค่าเริ่มต้น browser จะทำการ hard navigation ระหว่าง page หมายความว่า browser จะทำการ reload หน้าเพจและ reset React state เหมือนกับการใช้ useState และ reset browser state ให้กลับไปที่ค่าเริ่มต้น เช่น scroll postion ของ user หรือ fucused element\nแต่อย่างไรก็ตาม App Router ของ Next.js ใช้ soft navigation หมายความว่า React จะ render เฉพาะ segmment ที่มีการเปลี่ยนแปลงทั้ง React และ browser state และจะไม่ทำ full page reload","5-back-and-forward-navigation#5. Back and Forward navigation":"ค่าเริ่มต้นของ Next.js จะรักษา scroll position สำหรับ backward และ forward ไว้ และ re-use route segment ที่เก็บไว้ใน Router Cache","next-steps#Next Steps":"ต่อไปเราจะไปเรียนรู้เกี่ยวกับ 01-05-Route-Groups กัน\nแปลและเรียบเรียงโดย ModTdinOriginal: Linking and Navigating\n01-03-Pages-and-LayoutsHome"}},"/Next.js/01-Routing/01-05-Route-Groups":{"title":"01-05 การจัดกลุ่มของ Routes (Route Groups)","data":{"":"ในไดเรกทอรี app ใช้การสร้างโฟลเดอร์ซ้อนกัน(Nested folder) เป็นเครื่องมือในการสร้างเป็น URL path แต่เราก็สามารถสร้าง folder เพื่อกำหนดให้เป็นชื่อ Route Group ได้โดยที่โฟลเดอร์นี้ไม่มีการนำไปแสดงเป็นส่วนหนึ่งของ URL pathNext.js อนุญาตให้มีการจัดกลุ่มใน route segment และไฟล์ต่างๆในโปรเจก โดยไม่กระทบต่อโครงสร้าง URL pathประโยชน์ของ Route groups คือ\nจัดกลุ่มของ routes ให้เป็นหมวดหมู่ เช่น จัดกลุ่มโดย site section หรือโดยทีม\nการทำ nested layouts ในระดับเดียวกัน\nสร้าง nested layout ซ้อนกันหลายๆอันใน segment เดียวกัน รวมถึง หลายๆ root layouts\nเพิ่ม layout เข้าไปเป็นส่วนหนึ่งของ routes ใน segment ปกติ","ข้อกำหนด#ข้อกำหนด":"เราสามารถสร้าง route group ได้โดยการต้องชื่อโฟลเดอร์ไว้ในวงเล็บ เช่น (ชื่อโฟลเดอร์)","ตัวอย่าง-#ตัวอย่าง":"","การจัดหมวดหมู่ของ-routes-โดยไม่มีผลกระทบกับ-url-path#การจัดหมวดหมู่ของ Routes โดยไม่มีผลกระทบกับ URL path":"ในการจัดหมวดหมู่ของ route จะไม่ผลกระทบกับ URL การสร้างกลุ่มจะเก็บ routes ที่มีความสัมพันธ์กันไว้ด้วยกัน\nชื่อโฟลเดอร์ที่อยู่ในวงเล็บจะถูกละไว้ไม่ต้องใส่เข้าไปใน URL เช่น (marketing) หรือ (shop) ตามตัวอย่างในภาพ\nแม้ว่า routes ใน (marketing) และ (shop) จะใช้ URL เหมือนกัน แต่เราก็สามารถสร้างไฟล์ layout.js ในแต่ละกลุ่ม เพื่อสร้างการแสดงผลที่แตกต่างกันได้","opting-specific-segments-ใน-layout#Opting specific segments ใน layout":"การสร้าง layout เฉพาะ routes ที่เลือก เราทำได้โดยสร้าง route group ใหม่ ในที่นี้คือ (shop) และย้าย routes ที่ใช้ layout ร่วมกันเข้าไปใน group ในที่นี้คือ account และ cart ส่วนข้างนอก group จะไม่ได้ร่วมใช้ layout นี้","การสร้างหลาย-root-layout#การสร้างหลาย root layout":"ในการสร้างหลาย root layout ของ App Router ใน Next.js จะไม่มีการใช้ไฟล์ layout.js ในระดับบนสุด และจะสร้าง layout.js ในแต่ละ route groups แทน วิธีนี้จะเป็นประโยชน์มากสำหรับการแบ่งแอพพลิเคชันออกเป็นส่วนๆ แต่ละส่วนนั้นมี UI ที่แยกกัน ในกรณีนี้ต้องใส่ <html> และ <body> เข้าไปในแต่ละ root layout ด้วย\nจากตัวอย่างข้างบน ทั้ง (marketing) และ (shop) มี root layout ของมันเอง\nสิ่งที่ควรรู้\nการตั้งชื่อ route group ไม่มีความสำคัญอื่นๆ นอกจากบอกให้รู้หมวดหมู่ของ route นั้น และมันก็ไม่มีผลต่อ URL path\nRoutes ที่อยู่ใน rout group จะไม่ถูก resolve ใน path เดียวกัน เหมือนกับ path อื่นๆ เพราะว่า route group ไม่มีผลต่อโครงสร้าง URL เช่น (marketing)/about/page.js และ (shop)/about/page.js ทั้งสองอันนี้จะ resolve เป็น /about และนี่เป็นสาเหตุของการเกิด error\nถ้าเราใช้ root layout หลายอัน โดยไม่มี layout.js ในระดับบนสุด หน้า home ของ page.js จะใช้มีการหนึ่งใน route groups เช่น app/(marketing)/page.js\nการนำทางระหว่าง multi root layout จะทำให้เกิดการ load แบบ full page load ตัวอย่างเช่น การนำทางจาก /cart ที่ใช้ app/(shop)/layout.js ไป /blog ที่ใช้ app/(marketing)/layout.js แบบนี้จะทำให้เกิดการโหลดแบบ full page load ปรากฏการณ์นี้จะเกิดขึ้นเฉพาะการใช้ multi root layout เท่านั้น","next-steps#Next Steps":"ต่อไปเราจะไปเรียนรู้เกี่ยวกับ 01-06-Dynamic-Routes กัน\nแปลและเรียบเรียงโดย ModTdinOriginal: Route Groups\n01-04-Linking-and-NavigatingHome"}},"/Next.js/01-Routing/01-08-Error-Handling":{"title":"01-08 Error Handling","data":{"":"การกำหนดให้ใช้ไฟล์ error.js ทำให้เราสามารถจัดการกับ error ขณะทำงานที่เราคาดไม่ถึงใน nested routes ได้\nระบบจะมีการจัดให้ครอบ route segment และ nested children ของมันโดยอัตโนมัติใน React Error Boundary\nการสร้าง UI สำหรับบอก error จะใช้เฉพาะใน segment ที่ไฟล์ error.js อยู่เท่านั้น\nIsolate error มีผลกับ segment ระหว่างการทำงานของ function\nเป็นการเพิ่ม function เข้าไปเพื่อป้องกันการทำ full page reload หากเกิดการ error\nเราสามารถสร้าง UI เพื่อแสดง error ได้โดยการสร้าง error.js เข้าไปใน route segment และ export React component ออกมา\n\"use client\"; //Error component จะต้องเป็น Client Component เท่านั้น\nimport { useEffect } from \"react\";\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string };\n  reset: () => void;\n}) {\n  useEffect(() => {\n    // Log the error to an error reporting service\n    console.error(error);\n  }, []);\n  return (\n    <div>\n      <h2>Somthing went wrong!</h2>\n      <button\n        onClick={\n          // Attemp to recover by trying to re-render the segment\n          () => reset()\n        }\n      >\n        Try again\n      </button>\n    </div>\n  );\n}","errorjs-ทำงานอย่างไร#error.js ทำงานอย่างไร":"error.js จะสร้าง React Error Boundary ให้อัตโนมัติ โดยจะครอบ nested child segment หรือ page.js ไว้\nReact Component ที่ export จากไฟล์ error.js จะถูกใช้เป็น fallback component\nถ้ามีการโยน error เข้าไปใน error boundary ตัว error จะถูกเก็บไว้ และ rendered ตัว fallback component ออกไป\nเมื่อ fallback error ทำงาน ตัว layout ที่อยู่เหนือ error boundary จะยังคงทำงานอยู่ และสามารถ interactive ได้ และ error component จะทำหน้าที่แสดง error ที่เกิดขึ้นตามที่กำหนดไว้ เพื่อเป็นการ recover from the error\n(หัวข้อข้างล่างจะทำการ update ข้อมูลเร็วๆนี้)","recovering-from-errors#Recovering From errors":"ในบางครั้งสาเหตุของการเกิด error อาจจะเป็นเรื่องชั่วคราว ในกรณีแบบนี้เราแค่ทำการ refresh อีกครั้ง error ก็จะหายไปเราสามารถใช้ฟังก์ชัน reset() ในการแก้ไข error ให้กับ user ได้ โดยฟังก์ชันนี้จะทำการ render ในส่วนที่เกิด error ใหม่อีกครั้ง ถ้าทำสำเร็จ คือ ไม่เกิด error อีก จะทำการส่งผลการ render นั้นเข้าไปแทนที่ส่วนที่เกิด error เดิม\n\"use client\";\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string };\n  reset: () => void;\n}) {\n  return (\n    <div>\n      <h2>Something went wrong!</h2>\n      <button onClick={() => reset()}>Try again</button>\n    </div>\n  );\n}","nested-routes#Nested Routes":"React component ถูกสร้างผ่านไฟล์พิเศษ ที่ถูก render จากผังโครงสร้างเว็บเฉพาะ(specified nested hierachy)ตัวอย่างของ nested route ที่มี 2 segment โดยที่ทั้ง 2 segments นี้มี layout.js และ error.js ทั้งคู่ การ render จะเป็นไปตามผังโครงสร้างนี้\nerror.js จะมีการทำงานใน nested route ดังแสดงในภาพข้างล่างนี้\nจุดที่เกิด error จะอยู่ภายใต้ parent ที่ใกล้ที่สุด หมายความว่าไฟล์ error.js จะจัดการ error ทั้งหมดของ child segment ของมัน โดยจะแสดงเนื้อหา UI จากไฟล์ error.js ในสถานการณ์ต่างๆที่เกิดขึ้นใน nested folder ของ route นั้น\nerror.js จะไม่จัดการ error ที่เกิดขึ้นใน layout ที่อยู่ใน segmment เดียวกัน เพราะว่า ขอบเขตของ error นั้นอยู่ใน layout component","handling-error-in-layouts#Handling Error in Layouts":"error.js จะไม่จัดการ error ที่เกิดขึ้นใน layout ที่อยู่ใน segmment หรือ template.js เดียวกัน เพราะว่า ขอบเขตของ error นั้นอยู่ใน layout component นี่เป็นความตั้งใจเพื่อรักษา UI ที่สำคัญที่ใช้ร่วมกันระหว่าง route เช่น Navigationเพื่อที่จะจัดการ error ลักษณะนี้ เราจะวางไฟล์ error.js ไว้ใน layout ของ parent segmentหากเราต้องการจัดการ error ของ root layout หรือ template เราจะใช้ global-error.js","handling-errors-in-the-root-layouts#Handling Errors in the Root Layouts":"ใน root ไฟล์ app/error.js จะไม่สามารถจัดการ error ที่เกิดขึ้นใน component ของ app/layout.js หรือ app/template.jsใน root component มีวิธีการจัดการ error เฉพาะ คือ ใช้ app/global-error.js ที่อยู่ใน root ของ app directoryการทำงานของ global-error.js ไม่เหมือนกับการทำงานของ error.js เพราะว่า global-error.js จะครอบคลุมทั้งหมดของ app และ เมื่อ fallback component ของ global-error.js ทำงาน จะไปแทนที่ root layout ซึ่งจะต้องมีการระบุ <html> และ <body>แม้ว่าจะมีการกำหนด global-error.js ไว้แล้ว Next.js ก็ยังแนะนำให้สร้างไฟล์ error.js ใน root ซึ่งถูกเรียกให้แสดงผลภายใน layout ของ root ซึ่งรวมถึง UI ที่แชร์แบบ global และ branding\n\"use client\";\nexport default function GlobalError({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string };\n  reset: () => void;\n}) {\n  return (\n    <html>\n      <body>\n        <h2>Something went wrong!</h2>\n        <button onClick={() => reset()}>Try again</button>\n      </body>\n    </html>\n  );\n}","handling-server-errors#Handling Server Errors":"ถ้าเกิด error ขึ้นภายใน Server Component ตัว Next.js จะส่ง Error object (stripped of sensitive error information in production) ไปให้ error.js ที่อยู่ใกล้ที่สุด เหมือน error prop","securing-sensitive-error-information#Securing Sensitive Error information":"ในระหว่าง production ตัว error object จะถูกส่งไปที่ client จะประกอบไปด้วย message และ digestการทำแบบนี้เพื่อเป็นการป้องกัน การ leak ที่จะเกิดขึ้นในฝั่ง clientmessage เป็นข้อความทั่วไปเกี่ยวกับ error และ digest จะสร้าง hash ของ error โดยอัตโนมัติ ซึ่งจะตรงกับ error ที่เก็บไว้ใน sever-side LoadingSkeletonในระหว่างช่วง development error จะถูกส่งให้ client จะเป็นแบบ serealized และ มี message ของ error ต้นฉบับ อยู่ในนั้นด้วย เพื่อให้ง่ายต่อการ debugging","next-steps#Next Steps":"ต่อไปเราจะไปเรียนรู้เกี่ยวกับ Parallel Routes กัน\nแปลและเรียบเรียงโดย ModTdinOriginal: Error Handling"}},"/Next.js/01-Routing/01-09-Parallel-Routes":{"title":"01-09 Parallel Routes","data":{"":"การทำงานแบบ Parallel Routes จะทำให้เราสามารถ render หน้าเพจได้พร้อมๆกันหลายๆ หน้า ใน layout เดียวกัน สำหรับในส่วนที่เป็น Dynamic มากๆ ของแอพพลิเคชัน เช่น Dashboards หรือ การ feed ของ social site จะใช้ Parallel Routing กับ รูปแบบ routing ที่ซับซ้อนในการทำงานตัวอย่างในภาพ เราสามารถจะ render หน้า team และ analytics ได้พร้อมๆกัน\nในการทำ Parallel Routing นี้ เราสามารถระบุ error และ loading แยกกันของแต่ละ route ได้ และจะถูก streamed แยกกัน\nและ Parallel Routing ยังทำให้เราสามารถกำหนดเงื่อนไขการ render ในแต่ละเงื่อนไขได้ เช่น การทำ authentication การทำแบบนี้จะทำให้เราแยกโค้ดของแต่ละ condition ออกจากกันได้โดยยังใช้ URL เดียวกัน","ข้อกำหนด-convention#ข้อกำหนด (Convention)":"เราสามารถสร้าง Parallel Route โดยใช้ชื่อ slot ซึ่ง slot จะถูกกำหนดในรูปแบบของ @folder และส่งเป็น prop ให้กับ layout ใน level เดียวกัน\nSlot ไม่ใช่ route segment และ ไม่มีผลต่อโครงสร้าง URL เช่น /@team/members จะใช้แค่ /members ในการระบุ URL\nภาพต่อไปนี้จะแสดงตัวอย่างของโครงสร้างไฟล์ที่มี slot 2 slot คือ @analytics และ @team\nจากโครงสร้าง folder ข้างบน หมายความว่า component ใน app/layout.js มี slot ชื่อ @analytics และ @team และสามารถ render ทั้งสอง slot นี้แบบ children prop ได้พร้อมๆกัน\nexport default function Layout(prop: {\n  children: React.ReactNode;\n  analytics: React.ReactNode;\n  team: React.ReactNode;\n}) {\n  return (\n    <>\n      {props.children}\n      {props.team}\n      {props.analytics}\n    </>\n  );\n}\nสิ่งที่ควรรู้: เราไม่ต้องระบุ ชื่อ slot ของ children prop ในการระบุเส้นทาง เช่น app/page.js จะเท่ากับ app/@children/page.js","unmatched-routes#Unmatched Routes":"ค่าเริ่มต้นที่ Next.js กำหนดไว้ในการ render เนื้อหาใน slot คือ URL ปัจจุบันในกรณีที่เป็น unmatched slot ตัว Next.js จะทำการ render ด้วยวิธีการที่ต่างกันโดยใช้เทคนิคของ routing และ โครงสร้างโฟลเดอร์","defaultjs#default.js":"เราสามารถกำหนดไฟล์ default.js เพื่อให้ render เมื่อมีการ fallback ในกรณีที่ไม่สามารถจัดการกับ slot ที่ทำงานกับ condition ของ URL ปัจจุบันได้หากดูโครงสร้างโฟลเดอร์ของตัวอย่างในภาพข้างล่าง จะเห็นว่า slot ชื่อ @team จะมีไดเรกทอรี setting แต่ใน @analytics ไม่มี","navigation#Navigation":"ในการทำ Navigation ตัว Next.js จะ render slot ที่ใช้งานก่อนหน้านี้ แม้ว่าจะไม่ตรงกับ URL ปัจจุบันก็ตาม","reload#reload":"ในการ reload ตัว Next.js จะพยายาม render ไฟล์ default.jsใน slot ที่ unmatched ก่อน ถ้าไม่สามารถทำได้ หน้า 404 จะถูก render แทน\n404 สำหรับ unmatched routes จะช่วยให้เรามั่นใจว่า จะไม่เกิดความเสียหายจากการ render route ที่ไม่สามารถทำ parallel render ได้","useselectedlayoutsegments#useSelectedLayoutSegment(s)":"ทั้ง useSelectedLayoutSegment และ useSelectedLayoutSegments จะรับค่าจาก parallelRoutesKey ซึ่งจะทำให้เราสามารถอ่าน active route segment ใน slot นั้นได้\n\"use client\";\nimport { useSelectedLayoutSegment } from \"next/navigation\";\nexport default async function Layout(props: {\n  // ...\n  auth: React.ReactNode;\n}) {\n  const loginSegments = useSelectedLAlyoutSegment(\"auth\");\n  // ...\n}\nเมื่อ user ใช้ @auth/login หรือ /login ใน URL bar ตัว loginSegments จะมีค่าเท่ากับ string \"login\"","examples#Examples":"","modals#Modals":"Parallel Routing จะถูกใช้ใน render modal\nตัว slot @auth จะทำการ render <Modal> component ซึ่งจะทำให้สามารถแสดงการนำทางเพื่อที่จะ matching route ได้ เช่น /login\nexport default async function Layout(props: {\n  // ...\n  auth: React.ReactNode;\n}) {\n  <>\n    {/*...*/}\n    {props.auth}\n  </>;\n}\nimport { Modal } from 'components/modal'\nexport default function Login() {\n  return (\n    <Modal>\n  )\n}\nเพื่อให้แน่ใจว่า content ของ Modal นั้นจะไม่ถูก render เมื่อมันไม่ active เราสามารถสร้างไฟล์ default.js ให้ return null ออกมา\nexport default function Default() {\n  return null;\n}","dismissing-a-modal#Dismissing a modal":"ถ้า modal ถูกเรียกให้ทำงานผ่าน client navigation ตัวอย่างเช่น เรียกให้ทำงานผ่าน <Link href=\"/login\"> เราสามารถทำ dismiss โดยเรียก router.back() หรือ โดยการใช้ Link component\n\"use client\";\nimport { useRouter } from \"next/navigation\";\nimport { Modal } from \"component/modal\";\nexport default async function Login() {\n  const router = useRouter();\n  return (\n    <Modal>\n      <span onClick={() => router.back()}>Close modal</span>\n      <h1>Login</h1>\n      ...\n    </Modal>\n  );\n}\nสามารถดูข้อมูลเกี่ยวกับ modals เพิ่มเติมได้ใน Intercepting Routes\nถ้าเราต้องการให้นำทางไปที่ต่างๆและใช้ dismiss a modal เราสามารถทำได้โดยใช้ catch-all route\nexport default function CatchAll() {\n  return null;\n}\nการทำ Catch-all routes จะมีลำดับความสำคัญสูงกว่า default.js","conditional-routes#Conditional Routes":"Parallel Routes จะถูกใช้งานบนการกำหนดเงื่อนไขให้กับ routing ตัวอย่างเช่น เราสามารถ render slot ชื่อ @dashboard หรือ @login ขึ้นอยู่กับสถานะของการทำ authentigation\nimport { getUser } from \"@/lib/auth\";\nexport default function Layout({\n  dashboard,\n  login,\n}: {\n  dashboard: React.ReactNode;\n  login: React.ReactNode;\n}) {\n  const isLoggedIn = getUser();\n  return isLoggedIn ? dashboard : login;\n}","next-steps#Next Steps":"ต่อไปเราจะไปเรียนรู้เกี่ยวกับ Intercepting Routes กัน\nแปลและเรียบเรียงโดย ModTdinOriginal: Parallel Routes"}},"/Next.js/01-Routing/01-10-Intercepting-Routes":{"title":"01-10 Intercepting Routes","data":{"":"Intercepting Routes ทำให้เราสามารถ load route ที่อยู่ในส่วนอื่นๆของแอพพลิเคชันเข้ามาใน layout ปัจจุบันได้ แนวคิดนี้เป็นประโยชน์มากเมื่อเราต้องการแสดงเนื้อหาของ route โดยที่ user ไม่ต้องเปลี่ยนแปลงอะไรตัวอย่างเช่น เมื่อเรา clicke ที่รูปภาพใน feed เราจะแสดง photo ของ modal นั้นบนหน้า feed ในกรณีนี้ Next.js จะทำการ intercepts route /photo/123 เพื่อให้เป็นหน้ากากของ URL นั้นและแสดงทับชั้นบนสุดของ /feed\nแต่ว่า ถ้าเรา click ที่ shareable URL ของรูปหรือ refresh หน้าเพจนั้น รูปนั้นจะถูก render แทน modal จะไม่เกิด route intercept","ข้อกำหนด-convention#ข้อกำหนด (Convention)":"เราสามารถกำหนด Interception ได้โดยการใช้ (..) ซึ่งจะเหมือนกับ relative path ../ แต่ว่าสำหรับ segmentวิธีใช้\n(.) แทน segment ที่อยู่ในระดับเดียวกัน\n(..) แทน sagment ที่อยู่เหนือกว่า 1 ระดับ\n(..)(..) ใช้แทน segment ที่อยู่เหนือกว่า 2 ระดับ\n(...) แทน segment จาก root ของ app directory\nตัวอย่างเช่น เราสามารถ intercept photo segment จากใน feed segment ด้วยการสร้างได้เรกทอรี (..)photo\nหมายเหตุ เราจะใช้ (..) เฉพาะบน route segment ไม่ใช่บน file-system","ตัวอย่างของ#ตัวอย่างของ":"","modals#Modals":"เราสามารถใช้ Intercepting ร่วมกับ Parallel Routes ในการสร้าง modalsลำดับการสร้าง modals จะทำตามขั้นตอน ดังนี้\nสร้าง modal content ให้สามารถแชร์ผ่าน URL ได้\nPreserve context เมื่อเรา refresh page แทนที่จะปิด modal\nClose the modal on backward navigation แทน previous route\nReopen the modal on forwards navigation\nจากตัวอย่างข้างบน path ของ photo segment สามารถใช้ (..) มาจับคู่ได้ เพราะว่า @modal เป็น slot ไม่ใช่ segment หมายความว่า photo route อยู่ขึ้นไปหนึ่งระดับของ segment ในขณะที่ อยู่สูงขึ้นไป 2 ระดับใน file-system\nอีกตัวอย่างหนึ่ง เราสามารถใส่เข้าไปใน opening a login modal บน navbar ชั้นบนสุด ซึ่งมี /login page หรือ opening a shopping cart ใน side modalดูตัวอย่างของ modals ที่เกี่ยวกับ Intercepted และ Parallel Routes ได้ที่ https://github.com/vercel-labs/nextgram","next-steps#Next Steps":"ต่อไปเราจะไปเรียนรู้เกี่ยวกับ Route Handlers กัน\nแปลและเรียบเรียงโดย ModTdinOriginal: Intercepting Routes"}},"/Next.js/01-Routing/01-13-colocation":{"title":"01-13 Project Organization and File Colocation","data":{"":"จากหัวข้อ routing folder and file conventions, Next.js ยังไม่มีความเห็นเกี่ยวกับวิธีที่จะวางโครงสร้างและการจัดระเบียบไฟล์ในโปรเจกของคุณ.ในบทนี้เราจะมาแบ่งปันการจัดโครงสร้างของโปรเจกกัน ตามหัวข้อต่อไปนี้\nSafe colocation by default\nProject organization features\nProject organization strategies","safe-colocation-by-default#Safe colocation by default":"วางไฟล์ในตำแหน่งต่างๆมีความปลอดภัยตั้งแต่เริ่มต้น ใน app directory จะกำหนดโครงสร้าง route โดย ลำดับการวาง folder : nested folder hierarchy.ในแต่ละ folder จะเป็นตัวแทน route segment ของ URL path.ถึงแม้ว่า URL path จะถูกกำหนดผ่าน Folder แล้ว แต่ก็ยัง ไม่สามารถเข้าถึงได้จากภายนอก จนกว่าจะถูกกำหนดในไฟล์ page.js หรือ route.jsและแม้ว่า URL Path นั้นจะถูกกำหนดให้สามารถเข้าถึงได้จากภายนอกแล้ว จะมีเฉพาะ เนื้อหาที่เรากำหนดให้ returned โดย page.js หรือ route.js เท่านั้น ที่ถูกส่งไปให้ clientหมายความว่า ไฟล์ต่างๆใน Project จะอยู่ ในพื้นที่ปลอดภัย : safely colocated ข้างใน route segments ของ app directory โดยไม่ต้องกังวลว่าจะถูกเข้าถึงจากภายนอกโดยไม่ตั้งใจ\nสิ่งที่ควรรู้:\nในส่วนนี้ pages directory จะถือว่าไฟล์ทุกไฟล์ที่อยู่ใน pages เป็น route ที่เข้าถึงจากภายนอกได้ จุดนี้จึงเป็นข้อแตกต่างระหว่าง 'app' directory กับ 'pages directory\nถึงแม้ว่าคุณจะ สามารถ วางไฟล์ของคุณใน app ได้ แต่ไม่ได้เป็นข้อบังคับให้คุณต้องทำแบบนั้นเสมอไป หากคุณต้องการ เก็บไฟล์ไว้นอก app directory ก็สามารถทำได้","project-organization-features#Project organization features":"Next.js มีตัวช่วยในการจัดระเบียบโครงสร้าง project ของคุณ ดังหัวข้อที่่จะกล่าวต่อไปนี้","private-folders#Private Folders":"การกำหนดให้เป็น Folder แบบ private เราสามารถทำได้โดยการใส่เครื่องหมาย underscore หน้าชื่อ Folder แบบนี้ : _folderNameการทำแบบนี้จะเป็นการบอกกับ ระบบ route ของ Next.js ว่าเราไม่ต้องการ ให้นำ folder และ subfolders ทั้งหมดที่อยู่ใน folder นี้ มากำหนดเป็น route\nเพราะว่าไฟล์ใน app directory มีความปลอดภัยตามค่าเริ่มต้น อยู่แล้ว จึงไม่จำเป็นต้องทำเป็น private folders แต่การทำ private folder นี้จะนำไปในประโยชน์กับประเด็นต่อไปนี้:\nการแยกเก็บไฟล์ระหว่างไฟล์ที่ใช้กับ UI logic กับไฟล์ที่ใช้กับ routing logic.\nการจัดระเบียบไฟล์ในเพื่อใช้ระหว่างโปรเจกของ Next.js.\nการเรียงลำดับไฟล์ และ การจัดกลุ่มเพื่อให้ดูง่ายใน code editors.\nป้องกันการซ้ำกันของชื่อไฟล์ที่ Next.js จะกำหนดเพิ่มเติมในอนาคต\nสิ่งที่ควรรู้\nแม้ว่าจะไม่ใช่ข้อบังคับ แต่เราก็อาจจะใช้การตั้งชื่อแบบ private นี้กับ folder ที่อยู่นอกกับ folder อื่นๆที่ไม่ใช่ private ได้\nเราสามารถสร้าง URL segments ที่ขึ้นต้นด้วย underscore ได้โดยใส่เครื่องหมาย %5F (the URL-encoded form of an underscore) นำหน้าชื่อ folder ตามนี้: %5FfolderName.\nถ้าเราไม่ได้ใช้ private folder ของ Next.js แต่ก็เป็นประโยชน์ที่จะรู้เกี่ยวกับ special file conventions เพื่อป้องกันการเกิดปัญหาเกี่ยวข้องกับการตั้งชื่อโดยไม่คาดคิด","route-groups--การจัดกลุ่มของ-route#Route Groups : การจัดกลุ่มของ Route":"เราสามารถใช้เครื่องหมายวงเล็บ ครอบชื่อ folder ที่เราต้องการจัดกลุ่มได้ ตามตัวอย่างนี้ : (folderName)การทำแบบนี้มีจุดประสงค์เพื่อจัดโครงสร้างของ project เท่านั้น ชื่อกลุ่ม folder นี้ จะไม่ถูกรวม เข้าไปใน URL path ของ route นั้นการจัดกลุ่ม Route ใช้ประโยชน์สำหรับ :\nจัดการ routes ให้เป็นกลุ่ม เช่น แบ่งส่วนตามองค์ประกอบของ site แบ่งตามวัตถุประสงค์การทำงาน หรือแบ่งตามทีมทำงาน\nทำให้เราทำงานโดยใช้ nested layouts ที่ route segment ระดับเดียวกันได้ :\nการสร้าง nested layouts หลายระดับใน segment เดียวกัน รวมถึงการทำ multiple root layouts\nเพิ่ม layout ให้ subset of routes ที่ใช้ segment ร่วมกัน","src-directory#src Directory":"Next.js รองรับการเลือกเก็บไฟล์ code (including app) ใน src directory หมายถึง การแยก application code ออกจาก project configuration files","module-path-aliases--การตั้งชื่อใหม่เพื่อใช้แทน-path#Module Path Aliases : การตั้งชื่อใหม่เพื่อใช้แทน path":"Next.js รองรับ การตั้งชื่อ path ใหม่ เพื่อใช้แทน path เดิม ซึ่งจะทำให้เราอ่านและเรียกใช้ได้ง่ายขึ้นกว่าการเรียกชื่อ path ยาวๆเพราะว่าอยู่ใน ชั้นลึกๆที่ซ้อนกันอยู่หลายชั้น\n// before\nimport { Button } from \"../../../components/button\";\n// after\nimport { Button } from \"@/components/button\";","project-organization-strategies#Project organization strategies":"การวางโครงสร้างใน Next.js project ไม่มีคำว่า \"ถูก\" หรือ \"ผิด\"ที่สำคัญที่สุดคือ การวางโครงสร้าง Project ที่เหมาะกับคุณและทีมงานของคุณ และสามารถทำงานร่วมกับโปรเจกอื่นๆได้\nสิ่งที่ควรรู้: ตัวอย่างข้างล่าง เราใช้ folder ชื่อ components และ lib ตามรูปแบบทั่วไป ซึ่งไม่มีนัยสำคัญพิเศษกับ framework และเราสามารถใช้ชื่อว่า ui utils hooks styles และอื่นๆได้อีกด้วย","store-project-files-outside-of-app--การเก็บ-file-ของ-project-ไว้ข้างนอก-app#Store project files outside of app : การเก็บ file ของ project ไว้ข้างนอก app":"การทำแบบนี้ทำให้เราเก็บ code ทั้งหมดของ application ไว้ใน root ของ project และเก็บไฟล์สำหรับทำ routing โดยเฉพาะไว้ใน app directory","store-project-files-in-top-level-folders-inside-of-app--การเก็บ-file-ของ-project-ไว้ใน-app-ทั้งหมด#Store project files in top-level folders inside of app : การเก็บ file ของ project ไว้ใน app ทั้งหมด":"แนวทางนี้ เราจะเก็บไฟล์ทั้งหมดไว้ใน root ของ app directory.","split-project-files-by-feature-or-route--การแยกเก็บไฟล์ตามลักษณะการทำงานหรือตาม-route#Split project files by feature or route : การแยกเก็บไฟล์ตามลักษณะการทำงานหรือตาม route":"แนวทางนี้จะเก็บไฟล์ทั้งหมดไว้ใน app directory และ แยก เฉพาะ application code ไว้ใน route segments ที่ใช้."}},"/Next.js/02-data-fetching":{"title":"Data Fetching","data":{}},"/":{"title":"Index","data":{"":"ยินดีต้อนรับเข้าสู่ TheModDocu! เว็บที่พยายามแปลคู่มือโปรแกรมต่างๆให้เป็นภาษาไทยแบบเข้าใจง่ายที่สุดเท่าที่จะทำได้โดยเราจะเริ่มที่ Next.js เป็นอันดับแรก"}},"/Next.js/00-00-getting-started":{"title":"00-00 Next.js Getting Started","data":{"แนะนำ-nextjs#แนะนำ Next.js":"ยินดีต้อนรับเข้าสู่ การเรียนรู้ Next.js ภาษาไทย","nextjs-คืออะไร#Next.js คืออะไร":"Next.js คือ React framework สำหรับการสร้าง web applications แบบ full-stack\nเราใช้ React Components ในการสร้าง interface และ ใช้ Next.js สำหรับเพิ่มฟีเจอร์ที่มากขึ้น และ ทำให้มีประสิทธิภาพมากที่สุดNext.js จะตั้งค่าต่างๆที่ใช้กับ React ให้เราโดยอัตโนมัติ อย่างเช่น bundling การ compliling และอื่นๆ ซึ่งจะทำให้เราสามารถมีเวลาจดจ่อกับการสร้างแอพพลิเคชั่นมากขึ้น แทนที่จะมาเสียเวลาในการตั้งค่าต่างๆฺNext.js สามารถช่วยเราสร้าง interactive dynamic และ แอพลิเคชัน React ที่ทำงานได้เร็ว ไม่ว่าเราจะเป็นนักพัฒนาโปรแกรมแบบเดี่ยวๆ หรือ เป็นส่วนหนึ่งของทีมใหญ่","หัวข้อหลักๆของ-nextjs-main-features#หัวข้อหลักๆของ Next.js (Main Features)":"ตอนนี้เราจะขอแนะนำหัวข้อหลักๆที่เกี่ยวกับ Next.js ดังนี้","routing#Routing":"ระบบการจัดการไฟล์ในการสร้าง router ของ Server Components ซึ่งจะรองรับการทำงานของส่วนต่างๆดังนี้\n-layouts\n-nested routing\n-loading states\n-error handling\nและอื่นๆ","rendering#Rendering":"การ render ของ Client และ Server Component ทั้งในฝั่ง Client-side และ Server-side โดยปรับการ renderให้ทำงานอย่างเหมาะสมท้้งในรูปแบบ Static และ Dynamic บน server ด้วย Next.js รวมถึงการ Streaming บน Edge และ Node.js runtime","data-fetching#Data fetching":"ปรับการทำงานของ data fetching ให้ง่ายขึ้น โดยการใช้ async/await ใน sever Components และ ขยายความสามารถของ fetch API สำหรับการทำ - request memorization -data caching - revalidation","styling#Styling":"รองรับการทำ styling ทั้ง CSS TailwindCSS และ CSS-in-JSX","optimizations#Optimizations":"ทำการปรับปรุงคุณลักษณะของ Image, Fonts, and Script Optimizations ให้ดีขึ้น เพื่อปรับปรุง Core Web Vitals ของ web app และ User Experience ให้ดีขึ้น","typescript#TypeScript":"ปรับปรุงเพื่อให้รองรับการทำงานของ TypeScript ด้วยการตรวจสอบ type ที่ดีขึ้น และมีประสิทธิภาพในการ compliation มากขึ้น และปรับแต่ง Plugin ของ typeScript และตัวตรวจสอบ type","วิธีการใช้-คู่มือการเรียนรู้-nextjs-ฉบับภาษาไทยนี้#วิธีการใช้ คู่มือการเรียนรู้ Next.js ฉบับภาษาไทยนี้":"คู่มือนี้จะเรียงตามลำดับจากระดับพื้นฐานไปขั้นสูง การสร้างแอพพลิเคชั่น เราสามารถทำตามคู่มือไปทีละขั้นได้ แต่อย่างไรก็ตามคุณสามารถอ่านในหัวข้อต่างๆโดยไม่เรียงลำดับเพื่อนำเนื้อหาไปประยุกต์ใช้ตามที่ต้องการหากคุณต้องการเริ่มต้นตอนนี้เลย ให้ดูที่หัวข้อ การติดตั้ง Next.js","app-router-vs-pages-router#App Router vs Pages Router":"ใน Next.js มี router 2 แบบ คือ App Router และ Page Router","app-router#App Router":"App Router เป็น router แบบใหม่ ที่ทำให้เราสามารถใช้คุณสมบัติล่าสุดของ React ได้ อย่างเช่น Server Components และ Streaming","page-router#Page Router":"Page Router เป็น router แบบดั้งเดิม ของ Next.js ซึ่งจะให้เราสร้าง server-rendered ของ React application และรองรับ Next.js แบบเก่าได้ซึ่งในที่นี้เราจะกล่าวถึงเฉพาะ App Router ซึ่งเป็น router แบบใหม่เท่านั้น","ความรู้พื้นฐานที่ต้องมี#ความรู้พื้นฐานที่ต้องมี":"แม้ว่าคู่มือของเราจะพยายามทำให้เหมาะสำหรับผู้ที่เริ่มต้นใหม่ แต่ผู้อ่านก็ยังต้องมีพื้นฐานความรู้มาก่อน เพื่อให้ผู้เรียนจดจ่อกับการเรียนรู้การทำงานของ Next.js โดยเฉพาะเพื่อให้เกิดประสิทธิภาพสูงสุดในการเรียนรู้จากคู่มือเรา จึงขอแนะนำให้ผู้ที่ต้องการศึกษา ทำความเข้าใจความรู้พื้นฐานของ HTML CSS และ Reactหากคุณต้องการปรับพื้นฐานเกี่ยวกับ React ให้กดลิงก์ Next.js Fundamental Course\nแปลและเรียบเรียงโดย ModTdinOriginal: Introduction\nHome00-01-Installation"}},"/Next.js/01-Routing/01-03-Pages-and-Layouts":{"title":"01-03 การสร้าง Pages และ Layouts","data":{"":"เราแนะนำให้ทำความเข้าใจ ความรู้พื้นฐานเกี่ยวกับ Routing และ การกำหนด Route ก่อนที่จะเริ่มบทนี้\nบทนี้จะมีเนื้อหาเกี่ยวกับแนวทางการจัดการไฟล์พิเศษของ Next.js ที่ออกแบบใหม่ให้ง่ายขึ้น ไม่ว่าจะเป็นการสร้าง pages การสร้าง shared layouts และ template","การสร้าง-pages#การสร้าง Pages":"Page คือ หน้าแสดง UI เฉพาะของแต่ละ Route เราสามารถสร้าง Page โดย\nexport component จากไฟล์ page.js และใช้โฟลเดอร์ที่ไฟล์ page.js อยู่นั้นเป็น\nroute ในการเรียกให้ page.js แสดงผลการสร้างหน้าแรก เราจะสร้างไฟล์ pages.tsx ไว้ในไดเรกทอรี app\nจากภาพ เราจะได้ app/page.jsเป็น UI ของ / URL\n(ในตัวอย่างโค้ด เราสามารถใช้ไฟล์ .jsx หรือ .tsx แทน .js ได้)\n// โค้ดนี้จะใช้ `app/page.tsx` เป็น UI สำหรับ `/`\nexport default function Page() {\n    return <h1>Hello Home page!<h1/>\n}\nข้อควรรู้\nPage เป็นส่วนของ leaf ใน route subtree เสมอ\nเราสามารถใช้ไฟล์ .js .jsx .tsx สำหรับ Page ได้\nหากต้องการแสดงเนื้อหาของ route segment นั้น จะแสดงใน page.js เสมอ หากไม่มี page.js จะไม่มีการแสดงเนื้อหาของ route segment นั้น\nค่าเริ่มต้นของ Page จะตั้งให้เป็น Server Component แต่เราก็สามารถเปลี่ยนให้เป็น Client Component ได้\nPage สามารถ fetch data ได้ ซึ่งจะได้กล่าวถึงในหัวข้อ Data Fetching ต่อไป","layouts#Layouts":"Layout เป็น UI ที่ใช้ร่วมกันของ page หลายๆ page มักจะใช้ในการทำ\nnavigation\nlayouts preserve state\nremain interactive\nไม่มีการ render ซ้ำ\nและเราสามารถทำ layout ซ้อนใน layout อื่นได้เราสามารถกำหนด layout ได้โดย export React Component จากไฟล์ layout.js\nซึ่ง component จะต้องรับค่า children prop เพื่อให้ child layout(ถ้ามี) หรือ child page ไปใช้งาน\nexport default function DashboardLayout({\n  children, // willbe a page or nested layout\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <section>\n      {/* Include shared UI here e.g. a header or sidebar */}\n      <nav></nav>\n      {children}\n    </section>\n  );\n}\nสิ่งที่ควรรู้\nเราจะเรียก layout ชั้นบนสุดว่า Root Layout ซึ่งเป็นข้อกำหนดว่าจะต้องมีไม่มีไม่ได้ เพราะทำหน้าที่เป็น Layout ของทุก page ในแอพพลิเคชัน ใน Root layout นี้จะต้องมี html และ body tag อยู่ในนั้น\nเราสามารถกำหนด layout เพิ่มให้กับ route ต่างๆได้ ซึ่งจะใช้ได้กับทุก page ของ segment นั้นๆ\nค่าเริ่มต้น กำหนดให้ Layout ในแต่ละ route สามารถซ้อนกันได้ เราจะเรียก layout ชั้นสูงกว่าว่า parent layout จะครอบ child layout ที่อยู่ลำดับต่ำกว่าได้ โดยใช้ React children prop\nเราสามารถสร้าง Route Group เพื่อเป็นทางเลือกเฉพาะสำหรับแต่ละ segment ทั้งในและนอกขอบเขตของ shared layout ได้\nค่าเริ่มต้นของ Layout เป็น Server Component แต่เราก็สามารถตั้งค่าให้เป็น Client Component ได้\nLayout สามารถทำการ fetch data ได้ ให้ดูข้อมูลเพิ่มเติมในหัวข้อ Data Fetching\nเราไม่สามารถส่งข้อมูลระหว่าง parent layout และ Children ของมันได้ แต่อย่างไรก็ตาม เราสามารถ fetch ข้อมูลเดียวกันใน route นั้นได้มากกว่า 1 ครั้ง และ React สามารถทำการ dedupe the request อัตโนมัติโดยไม่กระทบกับประสิทธิภาพ\nLayout จะไม่มีการเข้าไปทำงานกับ route segment ในระดับที่ต่ำกว่ามันได้ หากจะทำให้สามารถเช้าถึงได้ในทุก route เราสามารถทำได้โดยใช้ useSelectedLayoutSegment หรือ ีuseSelectLAyoutSegmants ใน Client Component\nเราสามารถใช้ .js .jsx หรือ .tsx กับไฟล์ layout ได้\nเราสามารถสร้าง layout.js และ page.js ในโฟลเดอร์เดียวกันได้ ซึ่ง layout นั้นจะทำการครอบ page ไว้","root-layout-required#Root Layout (Required)":"Root layout จะถูกกำหนดให้อยู่ในระดับ top level ของไดเรกทอรี app และมีผลต่อทุก route ใน app\nใน layout นี้ เปิดให้คุณสามารถปรับแต่ง HTML ที่ return มาจาก server ได้\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  );\n}\nสิ่งที่ควรรู้\nไดเรกทอรี app จะต้องมี root layout\nroot layout จะต้องกำหนดแท็ก <html> และ <body> เพราะว่า Next.js ไม่สามารถสร้างเองได้\nเราสามารถใช้ <head> ของ HTML ในการทำงานกับ built-in SEO support ได้ เช่น การใช้ <title>\nเราสามารถใช้ route groups ในการสร้าง root layout หลายๆอันได้\nroot layout มีค่าเริ่มต้นเป็น Server Component และไม่สามารถเปลี่ยนให้เป็น Client Component ได้\nการใช้งานร่วมกับไดเรกทอรี pages จะแทน root layout ด้วยไฟล์ _app.js และ _document.js","nesting-layouts#Nesting Layouts":"เราจะทำการกำหนด Layout ใน folder ตัวอย่างเช่น app/dashboard/layout.js เพื่อให้มีผลการใช้งานกับ route ที่ต้องการ เช่น acme.com/dashboard และทำงานเมื่อ segment นั้นถูกเรียกให้ทำงาน\nค่าเริ่มต้นของ layout ในโครงสร้างไฟล์จะเป็น nested อยู่แล้ว หมายความว่า มันจะครอบ child layout ด้วย children prop\nexport default function DashboardLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return <section>{children}</section>;\n}\nสิ่งที่ควรรู้\nเฉพาะ root layout เท่านั้นที่จะมีแท็ก <html> และ <body> ได้\nถ้าเราต้องการนำ layoutข้างบน 2 อันมารวมกัน ตัว root layout (app/layout.js)จะต้องครอบ dashboard layout (app/dashboard/layout.js) ไว้ ซึ่งจะครอบ route segment\nไว้ข้างใน app/dashboard/*ข้างล่างนี้เป็นรูปตัวอย่างการซ้อน layout\nเราสามารถเลือกใช้ Route Groups สำหรับ route segment เพื่อกำหนดการ shared layout ได้","templates#Templates":"Template คล้ายกับ layout ที่ครอบ child layout หรือ page แต่ละอันไว้ แต่สิ่งที่ไม่เหมือนกัน layout คือ การคงอยู่ระหว่าง route และ maintain stateตัว template จะสร้าง instance ใหม่สำหรับการนำทางให้กับ children แต่ละตัว หมายความว่า เมื่อเราใช้ navigates ระหว่าง routes ที่ใช้ template ร่วมกัน จะมี instance ใหม่ที่ถูก mounted ขึ้นมา DOM element จะถูกสร้างขึ้นมาอีกครั้ง state จะไม่ถูกจองไว้ และ effects จะถูกเชื่อมกันอีกครั้งหมายความว่าอาจจะมีบางกรณีที่เราต้องการให้ทำงานเฉพาะ และ template ก็เป็นเครื่องมือที่เหมาะสมมากกว่า layout ตัวอย่างเช่น\nมีการทำงานบน useEffect (เช่น logging page view) และการใช้ useState (เช่น per-page feedback form)\nเพื่อเปลี่ยนแปลงผลของค่าเริ่มต้นของ framwork ตัวอย่างเช่น Suspense Boundaries ข้างใน Layout เพื่อแสดงเฉพาะ fallback เมื่อมีการโหลด layout ครั้งแรก หรือไม่โหลด เมื่อมีการเปลี่ยน pages ตัวอย่างเช่น fallback จะถูกแสดงในแต่ละการนำทาง\ntemplate สามารถตั้งค่าโดย export React component จาก template.js และ component จะต้องรับค่าจาก children prop\nexport default function Template({ children }: { chlidren: React.ReactNode }) {\n  return <div>{children}</div>;\n}\nในกรณีของ nesting ไฟล์ template.js จะถูก render ระหว่าง layout กับ children ของมัน ลองดูตัวอย่างของ output:\noutput\n<Layout>\n    {/* Note that the template is given a unique key. */}\n    <Template key={routeParam}>{children}</template>\n</Layout>","modifying-head#Modifying <head>":"ในไดเรกทอรี app เราสามารถปรับแต่ง <head> ซึ่งเป็น HTML element ได้ เช่น การปรับแต่ง title และ meta โดยการใช้ built-in SEO supportMetadata สามารถตั้งค่าโดยการ export ตัว meta object หรือ ฟังก์ชัน generateMetadata ในไฟล์ layout.js หรือ page.js\nimport { Metadata } from \"next\";\nexport const metadata: Metadata = {\n  title: \"Next.js\",\n};\nexport default function Page() {\n  return \"...\";\n}\nสิ่งที่ควรรู้\nเราไม่ควรเพิ่มแท็ก <head> เข้าไปใน root แบบ manual ขึ้นเอง เช่น <title> และ <meta> แต่ว่าเราจะใช้ Metadata API ซึ่งจะดำเนินการให้เราอัตโนมัติ เช่น straming และ de-duplication <head> element\nหากต้องการรู้เรื่อง metadata เพิ่มเติม ให้ดูในหัวข้อ API Reference","next-steps#Next Steps":"ต่อไปเราจะไปเรียนรู้เกี่ยวกับ 01-04-Linking-and-Navigating กัน\nแปลและเรียบเรียงโดย ModTdinOriginal: Pages and Layouts\n01-02-Defining-RoutesHome"}},"/Next.js/01-Routing/01-06-Dynamic-Routes":{"title":"01-06 Dynamic Routes","data":{"":"เมื่อเราไม่รู้ว่าชื่อ segment ที่แท้จริง และเราต้องการสร้าง routes จาก dynamic data เราสามารถใช้ dynamic segment ที่จะเติมเข้าไปตอนที่เราทำ request หรือ prerender ขณะ build time ได้","ข้อกำหนด-convention#ข้อกำหนด (Convention)":"เราสามารถสร้าง Dynamic Segment ได้โดยการครอบชื่อโฟลเดอร์ด้วยวงเล็บสี่เหลี่ยมในรูปแบบนี้ => [foldername] ตัวอย่าง เช่น [id] หรือ [slug]Dynamic Segment เป็นการส่งค่า params prop ไปให้ฟังก์ชัน layout page route และ generalMetadata","ตัวอย่าง#ตัวอย่าง":"ตอนนี้เราจะยกตัวอย่างในการใช้ เช่น เราสามารถใส่ dynamic route ให้กับ blog ได้ตามรูปแบบนี้ app/blog/[slug]/page.js ในที่นี้ [slug] ทำหน้าที่เป็น Dynamic Segment สำหรับ blog\nexport default function Page({ params }: { params: { slug: string } }) {\n  return <div>My Post: {params.slug}</div>;\n}\nRoutes\nExample URL\nparams\napp/blog/[blog]/page.js\n/blog/a\n{ slug: 'a'}\napp/blog/[blog]/page.js\n/blog/b\n{ slug: 'b'}\napp/blog/[blog]/page.js\n/blog/c\n{ slug: 'c'}\nดูหัวข้อ generateStaticParams() เพื่อเรียนรู้เพิ่มเติมเกี่ยวกับการ สร้าง params ของ segment\nสิ่งที่ควรรู้\nDynamic segment ก็คือ Dynamic Routes ใน pages directory","การสร้าง-static-params-generating-static-params#การสร้าง Static Params (Generating Static Params)":"ฟังก์ชัน generateStaticParams ศามารถใช้ร่วมกับ dynamic routes regments เพื่อสร้าง static generate routes ในขณะ build time แทนการสร้างเมื่อถูก request\nexport async function generateStaticParams() {\n  const posts = await fetch(\"https://.../posts\").then((res) => res.json());\n  return posts.map((post) => ({\n    slug: post.slug,\n  }));\n}\nประโยชน์ของการใช้ฟังก์ชัน generateStaticParams คือ การรับข้อมูลที่ดี ถ้าเนื้อหาถูก fetch โดยการใช้ genrateStaticParamsระบบจะจำไว้โดยอัตโนมัติ หมายความว่า fetch request ทำหน้าที่เหมือน argument ที่ทำงานข้าม generateStaticParams Layouts และ Pages` เป็นการสร้างขึ้นมาครั้งเดียวทำให้ลดเวลา build time(ใช้ migration guide ถ้าคุณต้องการให้ทำงานร่วมกับ pages directory)ดูหัวข้อ generateStaticParams server function component สำหรับการใช้ขั้นสูง","catch-all-segments#Catch-all segments":"Dynamic Segments ยังมีความสามารถที่จะทำการ catch-all ในแต่ละส่วนของ segment โดยเพิ่มจุด 3 จุด (ellipsis) เข้าไปในวงเล็บตามรูปแบบนี้ => [...folderName]ตัวอย่าง เช่น app/shop/[...slug]/page.js ใช้ได้กับ /shop/clothes และก็ยังใช้ได้กับ /shop/clothes/tops /shop/clothes/tops/t-shirts และอื่นๆ ได้อีกด้วย\nRoutes\nExample URL\nparams\napp/shop/[...slug]/page.js\n/shop/a\n{ slug: ['a']}\napp/shop/[...slug]/page.js\n/shop/a/b\n{ slug: ['a','b']}\napp/shop/[...slug]/page.js\n/shop/a/b/c\n{ slug: ['a','b','c']}","optional-catch-all-segments#Optional Catch-all Segments":"DCatch-all Segments ยังสามารถสร้างทางเลือกโดยการใช้ parameter ในวงเล็บสี่เหลี่ยมซ้อนกัน 2 ชั้นตามรูปแบบนี้=> [[...folderName]] ได้ตัวอย่าง เช่น app/shop/[[...slug]]/page.js ใช้ได้กับ /shop และก็ยังใช้ได้กับ /shop/clothes /shop/clothes/tops /shop/clothes/tops/t-shirts ได้ข้อแตกต่างระหว่าง catch-all กับ optional catch-all sement คือ optional ใช้กับ route ที่ไม่มี parameter ได้ เช่น /shop เป็นต้น\nRoutes\nExample URL\nparams\napp/shop/[[...slug]]/page.js\n/shop\n{}\napp/shop/[[...slug]]/page.js\n/shop/a\n{ slug: ['a']}\napp/shop/[[...slug[]/page.js\n/shop/a/b\n{ slug: ['a','b']}\napp/shop/[[...slug]]/page.js\n/shop/a/b/c\n{ slug: ['a','b','c']}","typescript#TypeScript":"เมื่อเราใช้ TypeScript เราจะสามารถเพิ่ม type สำหรับ params ได้ ขึ้นอยู่กับการตั้งค่าให้กับ route segment\nexport default function Page({ params }: { params: { slug: string } }) {\n  return <h1>My Page</h1>;\n}\nRoutes\nparams Type Definition\napp/blog/[slug]/page.js\n { slug: string }\napp/shop/[...slug]/page.js\n{ slug: string[]}\napp/[categoryId]/[itemId]/page.js\n{ categoryId: string, itemId: string }\nสิ่งที่ควรรู้\nเราอาจจะกำหนด type นี้ในอนาคต ด้วย TypeScript plugin","next-steps#Next Steps":"ต่อไปเราจะไปเรียนรู้เกี่ยวกับ Loading UI and Streaming กัน\nแปลและเรียบเรียงโดย ModTdinOriginal: Dynamic Routes\n01-05-Route-GroupsHome"}},"/Next.js/01-Routing/01-07-Loading-UI-and-Streaming":{"title":"01-07 Loading UI and Streaming","data":{"":"การใช้ไฟล์ loading.js ซึ่งเป็นไฟล์พิเศษเฉพาะช่วยในการแสดง UI เพื่อสื่อความหมายว่าการทำงานของ route segment อยู่ในสถานะกำลังโหลดข้อมูลจาก server เมื่อการโหลดข้อมูลเสร็จสิ้น ก็จะแสดงเนื้อหาที่โหลดมาโดยอัตโนมัติ โดยที่ไฟล์นี้จะมีความสัมพันธ์กับ React Suspense ซึ่งจะกล่าวถึงในอีกหัวข้อหนึ่ง","instant-loading-states#Instant Loading States":"Instant Loading States คือการเรียกใช้(fallback) UI เพื่อให้แสดงทันทีเมื่อมีการเรียกใช้ navigation เราสามารถทำการ pre-render ตัวแสดงสถานะขณะกำลังโหลด เตรียมไว้ก่อน เช่น การใช้ skeleton แสดง layout คร่าวๆของของข้อมูล หรือการแสดงตัว spinners เพื่อแสดงสถานะว่ากำลังโหลดข้อมูลอยู่ หรือการสื่อความหมายสำหรับหน้าจอที่จะแสดงผลต่อจากนี้ เช่น รูป cover หรือ title เป็นต้น การทำแบบนี้จะช่วยให้ผู้ใช้เข้าใจว่าแอพลิเคชันของเรากำลังทำงานอยู่ จึงทำให้ผู้ใช้เกิดประสบการณ์ที่ดีขึ้นเราสามารถสร้าง loading state โดยการสร้างไฟล์ loading.js เพิ่มเข้าไปในโฟลเดอร์ ดังแสดงในภาพข้างล่างนี้\nexport default function Loading() {\n  // เราสามารถใส่ UI แบบต่างๆเข้ามาใน loading รวมถึงสามารถใช้ Skeleton ตรงนี้ได้\n  return <LoadingSkeleton />;\n}\nloading.js จะถูกครอบไว้ใน layout.js ที่อยู่ในโฟลเดอร์เดียวกัน และมันจะครอบ page.js และ children ข้างล่างที่อยู่ในขอบเขตของ <Suspense> ให้โดยอัตโนมัติ\nสิ่งที่ควรรู้\nNavigtion จะทำงานทันทีร่วมกับ server-centric routing\nNavigation สามารถถูกขัดจังหวะการทำงานได้ หมายความว่า การเปลี่ยน route สามารถเกิดขึ้นได้ทันทีไม่ต้องรอให้โหลดเสร็จทั้งหมดก่อน ก่อนที่จะเปลี่ยนไป route อื่น\nlayout ที่ถูกใช้ร่วมกันยังคงทำงานอยู่แม้ว่ากำลังโหลด route segment ใหม่\nคำแนะนำ:\nใน Next.js จะใช้ loading.js ตามข้อกำหนดสำหรับ route segment (route และ pages) ให้เกิดความเหมาะสมมากที่สุด","streaming-with-suspense#Streaming with Suspense":"นอกจาก loading.js แล้วเรายังสามารถสร้าง Suspense Boundaries ขึ้นมาเองได้โดยใช้ UI ของเราเอง ใน App Router รองรับการ streaming ด้วย Suspense ทั้งใน Node.js และใน Edge runtime","streaming-คืออะไร#Streaming คืออะไร":"ในส่วนนี้เราจะมาเรียนรู้การทำงานของ Streaming ใน React และ Next.js เพื่อช่วยให้เราเข้าใจการทำงานและข้อจำกัดของ Server-Side Rendering(SSR)นี่คือขั้นตอนการทำงานของ SSR ที่ต้องทำให้เสร็จทุกขั้นตอนก่อนที่ผู้ใช้จะสามารถเห็นและใช้งานหน้าเพจนั้นได้\nข้อมูลทั้งหมดของหน้านั้นจะต้องถูก fetched บน server\nServer ทำการ render ให้เป็น HTML สำหรับหน้านั้น\nทั้ง HTML CSS และ JavaScript ของหน้านั้นจะถูกส่งไปที่ client\nทำการสร้าง HTML และ CSS โดยไม่แสดงส่วนที่เป็น interactive\nขั้นตอนสุดท้าย React hydrates เพื่อสร้าง interface ที่เป็น interactive ของหน้านั้น\nในขั้นตอนนี้จะทำงานเป็นลำดับขั้นและเป็นแบบ blocking หมายความว่า จะ render ข้อมูล HTML ทั้งหมดในครั้งเดียวที่มีการ fetched ข้อมูล และในฝั่ง client React สามารถทำได้แค่การ hydrate UI เมื่อโค้ดทั้งหมดทุก component ในหน้าเพจได้ถูกดาวน์โหลดเสร็จเรียบร้อยแล้วSSR กับ React และ Next.js จะทำการปรับปรุงประสิทธิภาพในการดาวน์โหลดร่วมกัน โดยแสดงเฉพาะข้อมูลเพจที่ไม่มี interactive ให้เร็วที่สุดเท่าที่เป็นไปได้\nแต่อย่างไรก็ตาม อาจจะยังช้าอยู่ถ้าการ fetch ข้อมูลทั้งหมดที่ต้องการบน server จะต้องเสร็จก่อนที่เพจจะแสดงให้ผู้ใช้ได้เห็นStreaming ทำให้เราแบ่ง HTML ของหน้าเพจเป็นส่วนเล็กๆ และ server จะทยอยส่งชิ้นส่วนเหล่านี้มาให้ client จนกว่าจะหมด\nการทำแบบนี้จะทำให้หน้าเพจค่อยๆแสดงทีละส่วนจนหมดโดยไม่ต้องรอให้ข้อมูลทั้งหมดถูก render ก่อนที่จะเปลี่ยนไปStreaming ทำงานได้ดีกับแอพในรูปแบบของ React component เพราะสามารถคิดว่าแต่ละ component คือแต่ละส่วนได้ Component ที่มีความสำคัญสูงกว่า เช่น product information หรือ component ที่ไม่ขึ้นอยู่กับข้อมูลเช่น layout จะได้รับการส่งมาก่อน ทำให้ React สามารถเริ่มทำการ hydration ได้เร็วขึ้น ส่วน Component ที่มีความสำคัญต่ำ เช่น review หรือ สินค้าที่เกี่ยวข้อง จะถูกส่งจาก request เดียวกันของ server หลังจากที่ ข้อมูลถูก fetched แล้ว\nการ Streaming นี้เป็นข้อได้เปรียบเมื่อเราต้องการป้องกันการ request ข้อมูลนานๆ จาก blocking page จากการ rendering นั่นคือการลด Time to First Byte(TTFB) และ First Contentful Paint(FCP) นั่นก็หมายความว่า ช่วยให้ Time to Interactive(TTI) ดีขึ้นด้วย โดยเฉพาะกับในอุปกรณ์ที่ทำงานช้า","ตัวอย่าง#ตัวอย่าง":"<suspense> จะทำงานโดยการครอบ component ที่ทำงานแบบ asynchronous action เช่น การ fetch ข้อมูล การแสดง fallback UI เช่น skeleton หรือ spinner เมื่อมันเกิดขึ้นและจะเปลี่ยนเป็นหน้าที่เราต้องการทันทีเมื่อการทำงานเสร็จสิ้น\nimport { Suspense } from \"react\";\nimport { PostFeed, Weather } from \"./Components\";\nexport default function Posts() {\n  return (\n    <section>\n      <Suspense fallback={<p>Loading feed...</p>}>\n        <PostFeed />\n      </Suspense>\n      <Suspense fallback={<p>Loading weather...</p>}>\n        <Weather />\n      </Suspense>\n    </section>\n  );\n}\nประโยชน์จากการใช้ <Suspense> คือ\nStreaming Server Rendering - ทำการทยอย Render HTML จาก server ไปให้ client\nSelective Hydration - React จะจัดลำดับความสำคัญก่อนหลังให้แต่ละ component ที่จะทำ interactive กับผู้ใช้\nสำหรับตัวอย่างเพิ่มเติมเกี่ยวกับ Suspense และวิธีการใช้งาน ศึกษาได้จาก React Document","seo#SEO":"Next.js จะรอให้ fetching data ข้างใน generateMetadata ให้เสร็จก่อนจึงจะทำการ streaming UI ไปให้ client เพื่อเป็นการรับประกันว่า ส่วนแรกที่ได้ทำการ streamed ไปแล้วมี <head> tag อยู่ด้วยแน่นอน\nเมื่อ streaming ถูก server render เสร็จ จะไม่ส่งผลกระทบต่อ SEO เราสามารถใช้เครื่องมือทดสอบชื่อ Mobile Friendly Test ของ google เพื่อดูว่า page ของเรามีลำดับการแสดงผลบน Google web crawler อย่างไรบ้าง และดูการเรียงลำดับของ HTML (source)","status-code#Status Code":"เมื่อเราทำการ streaming สำเร็จ จะมีการคืนค่าเป็นโค้ด 200 เพื่อแสดงว่า server ทำสิ่งที่ request มาสำเร็จและ Server ยังสามารถคืนค่า error หรือ issue ที่เกิดขึ้นไปให้ client พร้อมกับข้อมูลที่ stream ไปให้ client ด้วย ตัวอย่าง เช่น การใช้ redirect หรือ notFound เมื่อส่งส่วนของ headers ไปให้ client เสร็จเรียบร้อยแล้ว status code นี้จะไม่มีการ update อีก การทำแบบนี้จะไม่มีผลกระทบต่อ SEO","next-steps#Next Steps":"ต่อไปเราจะไปเรียนรู้เกี่ยวกับ Error Handling กัน\nแปลและเรียบเรียงโดย ModTdinOriginal: Loading UI and Streaming\n01-06-Dynamic-RoutesHome"}},"/Next.js/01-Routing/01-11-Route-Handlers":{"title":"01-11 Route Handlers","data":{"":"ในการจัดการ Routes เราสามารถจัดการ request เพื่อใช้กับ Request และ Response API ของ Web ได้\nสิ่งที่ควรรู้: การจัดการ Route ใช้ได้เฉพาะใน app directory\nจะเหมือนกับการทำ API Routes ของ Pages directory เราไม่ต้องใช้ API Routes และ Route Handlers คู่กัน","ข้อกำหนดการใช้งาน-convention#ข้อกำหนดการใช้งาน (Convention)":"เราจะกำหนด route handlers ไว้ในไฟล์ route.js | ts ข้างใน app directory:\nexport async function GET(request: Request) {}\nRoute Handlers สามารถถูกซ้อนข้างใน app directory เหมือนกับ page.js และ layout.js แต่ว่าไม่สามารถสร้างไฟล์ route.js ไว้ใน segment ระดับเดียวกันกับ page.js ได้","วิธีใช้งานกับ-http-methods#วิธีใช้งานกับ HTTP Methods":"methods ของ HTTP ที่สามารถใช้งานได้ คือ GET POST PUT PATCH DELETE HEAD และ OPTIONS แต่ถ้าหาก Next.js ไม่รองรับ method ไหน ก็จะทำการ return 405 Medthod Not Allowed กับมาเป็น Response","extended-nextrequest-และ-nextresponse-apis#Extended NextRequest และ NextResponse APIs":"์Nexy.js ได้มีการพัฒนาความสามารถของ Request และ Response เดิม ให้มีความสามารถใช้งานเพิ่มขี้น นั่นคือ NextRequest และ NextResponse","การใช้งาน-behavior#การใช้งาน (Behavior)":"","caching#Caching":"Route Handlers จะมีค่าเริ่มต้นเป็น cached เมื่อเราใช้เมธอด GET กับ Response object\nexport async function GET() {\n  const res = await fetch(\"https://data.mongodb-api.com/...\", {\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"API-Key\": process.env.Data_API_KEY,\n    },\n  });\n  const data = await res.json();\n  return Response.json({ data });\n}\nคำเตือนสำหรับ TypeScript: เราสามารถใช้ Response.json() ได้เฉพาะ TypeScript 5.2 ขึ้นไปเท่านั้น ถ้าต่ำกว่านี้เราสามารถใช้ NextResponse.json() แทน","opting-out-of-caching#Opting out of Caching":"เราสามารถเลือกใช้ caching ได้ดังนี้\nใช้ GET method ในการ Request object\nใช้ HTTP method อื่นๆ\nใช้ Dynamic Functions อย่าง cookies และ headers\nใช้ Segment Config Options เพื่อทำการตั้งค่า dynamic mode\nตัวอย่าง เช่น\nexport async function GET(request: Request) {\n  const { searchParams } = new URL(request.url);\n  const id = searchParams.get(\"id\");\n  const res = await fetch(\"https://data.mongodb-api.com/product/${id}\", {\n    header: {\n      \"Content-Type\": \"application/json\",\n      \"API-Key\": process.env.DATA_API_KEY,\n    },\n  });\n  const product = await res.json();\n  return Response.json({ product });\n}\nสำหรับ method POST ก็เหมือนกัน\nexport async function POST() {\n  const res = await fetch(\"https://data.mongodb-api.com/...\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"API-Key\": process.env.DATA_API_KEY,\n    },\n    body: JSON.stringify({ time: new Date().toISOString() }),\n  });\n  const data = await res.json();\n  return Response.json(data);\n}\nสิ่งที่ควรรู้: เราสามารถใช้ Route Handler ได้เหมือนกับ API routes ในการทำ form submission handling และยังมีสามารถทำ handling form and mutations ที่หลอมรวมกับ React ได้ลึกขึ้น","route-resolution#Route Resolution":"เราสามารถพิจารณา route ที่ระดับสุดได้ ดังนี้\nมันจะไม่เป็นส่วนหนึ่งของ layout หรือ client-side navigtion เช่น page\nจะไม่สามารถมี route.js ใน route เดียวกันกับ page.js\nPage\tRoute\tResult\tapp/page.js\tapp/route.js\t<Cross size={18} /> Conflict\tapp/page.js\tapp/api/route.js\t<Check size={18} /> Valid\tapp/[user]/page.js\tapp/api/route.js\t<Check size={18} /> Valid","url-query-parameters#URL Query Parameters":"The request object passed to the Route Handler is a NextRequest instance, which has some additional convenience methods, including for more easily handling query parameters.\nimport { type NextRequest } from \"next/server\";\nexport function GET(request: NextRequest) {\n  const searchParams = request.nextUrl.searchParams;\n  const query = searchParams.get(\"query\");\n  // query is \"hello\" for /api/search?query=hello\n}","streaming#Streaming":"Streaming is commonly used in combination with Large Language Models (LLMs), such as OpenAI, for AI-generated content. Learn more about the AI SDK.\nimport { Configuration, OpenAIApi } from \"openai-edge\";\nimport { OpenAIStream, StreamingTextResponse } from \"ai\";\nexport const runtime = \"edge\";\nconst apiConfig = new Configuration({\n  apiKey: process.env.OPENAI_API_KEY!,\n});\nconst openai = new OpenAIApi(apiConfig);\nexport async function POST(req: Request) {\n  // Extract the `messages` from the body of the request\n  const { messages } = await req.json();\n  // Request the OpenAI API for the response based on the prompt\n  const response = await openai.createChatCompletion({\n    model: \"gpt-3.5-turbo\",\n    stream: true,\n    messages: messages,\n    max_tokens: 500,\n    temperature: 0.7,\n    top_p: 1,\n    frequency_penalty: 1,\n    presence_penalty: 1,\n  });\n  // Convert the response into a friendly text-stream\n  const stream = OpenAIStream(response);\n  // Respond with the stream\n  return new StreamingTextResponse(stream);\n}\nThese abstractions use the Web APIs to create a stream. You can also use the underlying Web APIs directly.\n// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_stream\nfunction iteratorToStream(iterator: any) {\n  return new ReadableStream({\n    async pull(controller) {\n      const { value, done } = await iterator.next();\n      if (done) {\n        controller.close();\n      } else {\n        controller.enqueue(value);\n      }\n    },\n  });\n}\nfunction sleep(time: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, time);\n  });\n}\nconst encoder = new TextEncoder();\nasync function* makeIterator() {\n  yield encoder.encode(\"<p>One</p>\");\n  await sleep(200);\n  yield encoder.encode(\"<p>Two</p>\");\n  await sleep(200);\n  yield encoder.encode(\"<p>Three</p>\");\n}\nexport async function GET() {\n  const iterator = makeIterator();\n  const stream = iteratorToStream(iterator);\n  return new Response(stream);\n}","request-body#Request Body":"You can read the Request body using the standard Web API methods:\nexport async function POST(request: Request) {\n  const res = await request.json();\n  return Response.json({ res });\n}","request-body-formdata#Request Body FormData":"You can read the FormData using the request.formData() function:\nexport async function POST(request: Request) {\n  const formData = await request.formData();\n  const name = formData.get(\"name\");\n  const email = formData.get(\"email\");\n  return Response.json({ name, email });\n}\nSince formData data are all strings, you may want to use zod-form-data to validate the request and retrieve data in the format you prefer (e.g. number).","cors#CORS":"You can set CORS headers on a Response using the standard Web API methods:\nexport async function GET(request: Request) {\n  return new Response(\"Hello, Next.js!\", {\n    status: 200,\n    headers: {\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, OPTIONS\",\n      \"Access-Control-Allow-Headers\": \"Content-Type, Authorization\",\n    },\n  });\n}","edge-and-nodejs-runtimes#Edge and Node.js Runtimes":"Route Handlers have an isomorphic Web API to support both Edge and Node.js runtimes seamlessly, including support for streaming. Since Route Handlers use the same route segment configuration as Pages and Layouts, they support long-awaited features like general-purpose statically regenerated Route Handlers.You can use the runtime segment config option to specify the runtime:\nexport const runtime = \"edge\"; // 'nodejs' is the default","non-ui-responses#Non-UI Responses":"You can use Route Handlers to return non-UI content. Note that sitemap.xml, robots.txt, app icons, and open graph images all have built-in support.\nexport async function GET() {\n  return new Response(`<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<rss version=\"2.0\">\n<channel>\n  <title>Next.js Documentation</title>\n  <link>https://nextjs.org/docs</link>\n  <description>The React Framework for the Web</description>\n</channel>\n</rss>`);\n}","segment-config-options#Segment Config Options":"Route Handlers use the same route segment configuration as pages and layouts.\nexport const dynamic = \"auto\";\nexport const dynamicParams = true;\nexport const revalidate = false;\nexport const fetchCache = \"auto\";\nexport const runtime = \"nodejs\";\nexport const preferredRegion = \"auto\";\nSee the API reference for more details.\n(จะทำการ update เนื้อหาต่อไป)","next-steps#Next Steps":"ต่อไปเราจะไปเรียนรู้เกี่ยวกับ Middleware กัน\nแปลและเรียบเรียงโดย ModTdinOriginal: Intercepting Routes"}},"/Next.js/01-Routing/01-12-Middleware":{"title":"01-12 Middleware","data":{"":"Middleware ทำให้เราสามารถ run code ก่อนที่การ request จะจบลง ดังนั้นเมื่อ request ตัวต่อไปจะส่งเข้ามา เราสามารถปรับแต่ง response ได้โดยการเขียนซ้ำ หรือ เปลี่ยนการนำทาง หรือ ปรับแต่ง request หรือ response header หรือ สามารถ respond ตรงๆเลยMiddleware จะทำงานก่อนที่จะทำการจับคู่ระหว่าง content ที่เก็บไว้ใน cache กับ routes ดูเพิ่มเติมได้ที่หัวข้อ Matching Paths","ข้อกำหนด#ข้อกำหนด":"เราจะใช้ไฟล์ชื่อว่า middleware.ts (หรือว่า .js) ใน root ของโปรเจคเพื่อกำหนดค่า Middleware ตัวอย่างเช่น ที่ระดับเดียวกันกับโฟลเดอร์ app","ตัวอย่าง#ตัวอย่าง":"import { NextResponse } from \"next/server\";\nimport type { NextRequest } from \"next/server\";\n// ฟังก์ชันนี้สามารถกำหนดให้ `async` ทำงานได้ ถ้าเราต้องการใช้ `await` ข้างใน\nexport function middleware(request: NextRequest) {\n  return NextResponse.redirect(new URL(\"/home\", request.url));\n}\n// ดูเพิ่มเติมในหัวข้อ \"Matching Paths\"\nexport const config = {\n  matcher: \"/about/:path*\",\n};","matching-paths#Matching Paths":"Middleware จะทำการร้องขอจาก ทุกๆ routes ใน project ของเรา ตามลำดับดังต่อไปนี้:\nheaders จาก next.config.js\nredirects จาก next.config.js\nMiddleware (rewrites, redirects, etc.)\nbeforeFiles (rewrites) จาก next.config.js\nFilesystem routes (public/, _next/static/, pages/, app/, etc.)\nafterFiles (rewrites) จาก next.config.js\nDynamic Routes (/blog/[slug])\nfallback (rewrites) จาก next.config.js\nในการกำหนด paths การทำงานของ Middleware มี 2 แนวทาง คือ\nCustom matcher config\nConditional statements","matcher#Matcher":"matcher เราจะเลือก run เฉพาะ Middleware ใน path ที่กำหนดไว้\nexport const config = {\n  matcher: \"/about/:path*\",\n};\nเราสามารถจับคู่กับ path เดียว หรือ หลายๆ paths ในรูปแบบ array ก็ได้\nexport const config = {\n  matcher: [\"/about/:path*\", \"/dashboard/:path*\"],\n};\nเราสามารถกำหนดให้ matcher ทำ full regex เพื่อรองรับเฉพาะตัวอักษรที่เรากำหนดไว้ เช่น ต้องตรงกับ path ที่ระบุไว้ ลองดูตัวอย่างข้างล่างประกอบ\nexport const config = {\n  matcher: [\n    /*\n     * ชื่อ paths ที่ต้องการจะต้องตรงกับเงื่อนไขที่ระบุไว้ตามเงื่อนไขใดเงื่อนไขหนึ่ง ต่อไปนี้\n     * - api (API routes)\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico (favicon file)\n     */\n    \"/((?!api|_next/static|_next/image|favicon.ico).*)\",\n  ],\n};\nGood to know: The matcher values need to be constants so they can be statically analyzed at build-time. Dynamic values such as variables will be ignored.\nConfigured matchers:\nMUST start with /\nCan include named parameters: /about/:path matches /about/a and /about/b but not /about/a/c\nCan have modifiers on named parameters (starting with :): /about/:path* matches /about/a/b/c because * is zero or more. ? is zero or one and + one or more\nCan use regular expression enclosed in parenthesis: /about/(.*) is the same as /about/:path*\nRead more details on path-to-regexp documentation.\nความรู้เพิ่มเติม: สำหรับ backward compatibility ใน Next.js จะมอง /public ว่าเป็น /public/index นั่นก็คือ matcher ของ public/:path นั่นเอง\nGood to know: For backward compatibility, Next.js always considers /public as /public/index. Therefore, a matcher of /public/:path will match.","conditional-statements#Conditional Statements":"import { NextResponse } from \"next/server\";\nimport type { NextRequest } from \"next/server\";\nexport function middleware(request: NextRequest) {\n  if (request.nextUrl.pathname.startsWith(\"/about\")) {\n    return NextResponse.rewrite(new URL(\"/about-2\", request.url));\n  }\n  if (request.nextUrl.pathname.startsWith(\"/dashboard\")) {\n    return NextResponse.rewrite(new URL(\"/dashboard/user\", request.url));\n  }\n}","conditional-statements-1#Conditional Statements":"import { NextResponse } from \"next/server\";\nimport type { NextRequest } from \"next/server\";\nexport function middleware(request: NextRequest) {\n  if (request.nextUrl.pathname.startsWith(\"/about\")) {\n    return NextResponse.rewrite(new URL(\"/about-2\", request.url));\n  }\n  if (request.nextUrl.pathname.startsWith(\"/dashboard\")) {\n    return NextResponse.rewrite(new URL(\"/dashboard/user\", request.url));\n  }\n}","nextresponse#NextResponse":"The NextResponse API allows you to:\nredirect the incoming request to a different URL\nrewrite the response by displaying a given URL\nSet request headers for API Routes, getServerSideProps, and rewrite destinations\nSet response cookies\nSet response headers\nTo produce a response from Middleware, you can:\nrewrite to a route (Page or Route Handler) that produces a response\nreturn a NextResponse directly. See Producing a Response","using-cookies#Using Cookies":"Cookies are regular headers. On a Request, they are stored in the Cookie header. On a Response they are in the Set-Cookie header. Next.js provides a convenient way to access and manipulate these cookies through the cookies extension on NextRequest and NextResponse.\nFor incoming requests, cookies comes with the following methods: get, getAll, set, and delete cookies. You can check for the existence of a cookie with has or remove all cookies with clear.\nFor outgoing responses, cookies have the following methods get, getAll, set, and delete.\nimport { NextResponse } from \"next/server\";\nimport type { NextRequest } from \"next/server\";\nexport function middleware(request: NextRequest) {\n  // Assume a \"Cookie:nextjs=fast\" header to be present on the incoming request\n  // Getting cookies from the request using the `RequestCookies` API\n  let cookie = request.cookies.get(\"nextjs\");\n  console.log(cookie); // => { name: 'nextjs', value: 'fast', Path: '/' }\n  const allCookies = request.cookies.getAll();\n  console.log(allCookies); // => [{ name: 'nextjs', value: 'fast' }]\n  request.cookies.has(\"nextjs\"); // => true\n  request.cookies.delete(\"nextjs\");\n  request.cookies.has(\"nextjs\"); // => false\n  // Setting cookies on the response using the `ResponseCookies` API\n  const response = NextResponse.next();\n  response.cookies.set(\"vercel\", \"fast\");\n  response.cookies.set({\n    name: \"vercel\",\n    value: \"fast\",\n    path: \"/\",\n  });\n  cookie = response.cookies.get(\"vercel\");\n  console.log(cookie); // => { name: 'vercel', value: 'fast', Path: '/' }\n  // The outgoing response will have a `Set-Cookie:vercel=fast;path=/test` header.\n  return response;\n}\nimport { NextResponse } from \"next/server\";\nexport function middleware(request) {\n  // Assume a \"Cookie:nextjs=fast\" header to be present on the incoming request\n  // Getting cookies from the request using the `RequestCookies` API\n  let cookie = request.cookies.get(\"nextjs\");\n  console.log(cookie); // => { name: 'nextjs', value: 'fast', Path: '/' }\n  const allCookies = request.cookies.getAll();\n  console.log(allCookies); // => [{ name: 'nextjs', value: 'fast' }]\n  request.cookies.has(\"nextjs\"); // => true\n  request.cookies.delete(\"nextjs\");\n  request.cookies.has(\"nextjs\"); // => false\n  // Setting cookies on the response using the `ResponseCookies` API\n  const response = NextResponse.next();\n  response.cookies.set(\"vercel\", \"fast\");\n  response.cookies.set({\n    name: \"vercel\",\n    value: \"fast\",\n    path: \"/\",\n  });\n  cookie = response.cookies.get(\"vercel\");\n  console.log(cookie); // => { name: 'vercel', value: 'fast', Path: '/' }\n  // The outgoing response will have a `Set-Cookie:vercel=fast;path=/test` header.\n  return response;\n}","setting-headers#Setting Headers":"You can set request and response headers using the NextResponse API (setting request headers is available since Next.js v13.0.0).\nimport { NextResponse } from \"next/server\";\nimport type { NextRequest } from \"next/server\";\nexport function middleware(request: NextRequest) {\n  // Clone the request headers and set a new header `x-hello-from-middleware1`\n  const requestHeaders = new Headers(request.headers);\n  requestHeaders.set(\"x-hello-from-middleware1\", \"hello\");\n  // You can also set request headers in NextResponse.rewrite\n  const response = NextResponse.next({\n    request: {\n      // New request headers\n      headers: requestHeaders,\n    },\n  });\n  // Set a new response header `x-hello-from-middleware2`\n  response.headers.set(\"x-hello-from-middleware2\", \"hello\");\n  return response;\n}\nimport { NextResponse } from \"next/server\";\nexport function middleware(request) {\n  // Clone the request headers and set a new header `x-hello-from-middleware1`\n  const requestHeaders = new Headers(request.headers);\n  requestHeaders.set(\"x-hello-from-middleware1\", \"hello\");\n  // You can also set request headers in NextResponse.rewrite\n  const response = NextResponse.next({\n    request: {\n      // New request headers\n      headers: requestHeaders,\n    },\n  });\n  // Set a new response header `x-hello-from-middleware2`\n  response.headers.set(\"x-hello-from-middleware2\", \"hello\");\n  return response;\n}\nGood to know: Avoid setting large headers as it might cause 431 Request Header Fields Too Large error depending on your backend web server configuration.","producing-a-response#Producing a Response":"You can respond from Middleware directly by returning a Response or NextResponse instance. (This is available since Next.js v13.1.0)\nimport { NextRequest } from \"next/server\";\nimport { isAuthenticated } from \"@lib/auth\";\n// Limit the middleware to paths starting with `/api/`\nexport const config = {\n  matcher: \"/api/:function*\",\n};\nexport function middleware(request: NextRequest) {\n  // Call our authentication function to check the request\n  if (!isAuthenticated(request)) {\n    // Respond with JSON indicating an error message\n    return Response.json(\n      { success: false, message: \"authentication failed\" },\n      { status: 401 }\n    );\n  }\n}\nimport { isAuthenticated } from \"@lib/auth\";\n// Limit the middleware to paths starting with `/api/`\nexport const config = {\n  matcher: \"/api/:function*\",\n};\nexport function middleware(request) {\n  // Call our authentication function to check the request\n  if (!isAuthenticated(request)) {\n    // Respond with JSON indicating an error message\n    return Response.json(\n      { success: false, message: \"authentication failed\" },\n      { status: 401 }\n    );\n  }\n}","advanced-middleware-flags#Advanced Middleware Flags":"In v13.1 of Next.js two additional flags were introduced for middleware, skipMiddlewareUrlNormalize and skipTrailingSlashRedirect to handle advanced use cases.skipTrailingSlashRedirect allows disabling Next.js default redirects for adding or removing trailing slashes allowing custom handling inside middleware which can allow maintaining the trailing slash for some paths but not others allowing easier incremental migrations.\nmodule.exports = {\n  skipTrailingSlashRedirect: true,\n};\nconst legacyPrefixes = [\"/docs\", \"/blog\"];\nexport default async function middleware(req) {\n  const { pathname } = req.nextUrl;\n  if (legacyPrefixes.some((prefix) => pathname.startsWith(prefix))) {\n    return NextResponse.next();\n  }\n  // apply trailing slash handling\n  if (\n    !pathname.endsWith(\"/\") &&\n    !pathname.match(/((?!\\.well-known(?:\\/.*)?)(?:[^/]+\\/)*[^/]+\\.\\w+)/)\n  ) {\n    req.nextUrl.pathname += \"/\";\n    return NextResponse.redirect(req.nextUrl);\n  }\n}\nskipMiddlewareUrlNormalize allows disabling the URL normalizing Next.js does to make handling direct visits and client-transitions the same. There are some advanced cases where you need full control using the original URL which this unlocks.\nmodule.exports = {\n  skipMiddlewareUrlNormalize: true,\n};\nexport default async function middleware(req) {\n  const { pathname } = req.nextUrl;\n  // GET /_next/data/build-id/hello.json\n  console.log(pathname);\n  // with the flag this now /_next/data/build-id/hello.json\n  // without the flag this would be normalized to /hello\n}","next-steps#Next Steps":"ต่อไปเราจะไปเรียนรู้เกี่ยวกับ Project Organization กัน\nแปลและเรียบเรียงโดย ModTdinOriginal: Middleware"}},"/Next.js/01-Routing/01-14-internationallization":{"title":"01-14 Internationalization","data":{"":"ใน Next.js เราสามารถกำหนดให้เรียงลำดับ และ render เนื้อหาเพื่อรองรับหลายภาษาได้ ซึ่งทำได้ทั้งเนื้อหา (localization) และ route","terminology#Terminology":"Locale: เป็นรหัสสำหรับกำหนดชุดของภาษาและการจัดรูปแบบ รวมถึงภูมิภาคที่อยู่\nen-US: ภาษาอังกฤษสำหรับผู้ที่อาศัยใน United States\nnl-NL: ภาษา Dutch ที่ใช้ใน Netherlands\nnl: ภาษา Dutch ไม่ระบุพื้นที่","routing-overview#Routing Overview":"แนะนำให้ใช้การตั้งค่าภาษาของผู้ใช้ใน browser ซึ่งผู้ใช้ได้กำหนดค่าไว้ การเปลี่ยนภาษาของแอพจะเป็นการแก้ไข Accept-Language ใน application ของเราตัวอย่าง code ข้างล่าง เป็นการรับ Request ที่เข้ามาเพื่อไปหา locale ที่เลือกจาก Headers locales และ default locale ที่เรากำหนดไว้\nimport { match } from \"@formatjs/intl-localematcher\";\nimport Negotiator from \"negotiator\";\nlet headers = { \"accept-language\": \"en-US,en;q=0.5\" };\nlet languages = new Negotiator({ headers }).languages();\nlet locales = [\"en-US\", \"nl-NL\", \"nl\"];\nlet defaultLocale = \"en-US\";\nmatch(languages, locales, defaultLocale); // -> 'en-US'\nการกำหนด Routing ให้สามารถรองรับหลายภาษาได้โดยใส่ sub-path (/fr/products) หรือ domain (my-site.fr/products) ด้วยการทำอย่างนี้เราสามารถเปลี่ยนเส้นทาง (redirect) นำผู้ใช้ไปยังที่ต่างที่กำหนด locale ไว้ใน Middleware.\nlet locales = ['en-US', 'nl-NL', 'nl']\n// Get the preferred locale, similar to the above or using a library\nfunction getLocale(request) { ... }\nexport function middleware(request) {\n  // Check if there is any supported locale in the pathname\n  const { pathname } = request.nextUrl\n  const pathnameHasLocale = locales.some(\n    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`\n  )\n  if (pathnameHasLocale) return\n  // Redirect if there is no locale\n  const locale = getLocale(request)\n  request.nextUrl.pathname = `/${locale}${pathname}`\n  // e.g. incoming request is /products\n  // The new URL is now /en-US/products\n  return Response.redirect(request.nextUrl)\n}\nexport const config = {\n  matcher: [\n    // Skip all internal paths (_next)\n    '/((?!_next).*)',\n    // Optional: only run on root (/) URL\n    // '/'\n  ],\n}\nและขั้นตอนสุดท้าย คือ การตรวจสอบไฟล์ต่างๆใน app/ ซึ่งมี app/[lang] อยู่ข้างใน การทำแบบนี้จะทำให้ Next.js จัดการ router ให้เปลี่ยนไปตาม locales ใน และส่งพารามิเตอร์ lang ไปยัง layout and page ดังตัวอย่างต่อไปนี้ :\n// You now have access to the current locale\n// e.g. /en-US/products -> `lang` is \"en-US\"\nexport default async function Page({ params: { lang } }) {\n  return ...\n}\nการทำแบบนี้ทำให้มี folder ใหม่ อยู่ใน root layout ตามตัวอย่าง คือ app/[lang]/layout.js","localization#Localization":"การแสดงเนื้อหาตามภาษาที่ผู้ใช้เลือก ไม่ได้มีเฉพาะกับ Next.js เท่านั้น แต่ web application อื่นๆ ก็สามารถทำได้เหมือนกันตัวอย่างต่อไปนี้จะสมมติว่า ใช้ภาษา English และ Dutch เราก็สามารถทำ “dictionaries”ของทั้งสองภาษาขึ้นมา และจับคู่ key เข้ากับ localized string ดังนี้:\n{\n  \"products\": {\n    \"cart\": \"Add to Cart\"\n  }\n}\n{\n  \"products\": {\n    \"cart\": \"Toevoegen aan Winkelwagen\"\n  }\n}\nเราสามารถสร้างฟังก์ชัน getDictionary เพื่อ load คำแปลตามภาษาที่เลือก :\nimport \"server-only\";\nconst dictionaries = {\n  en: () => import(\"./dictionaries/en.json\").then((module) => module.default),\n  nl: () => import(\"./dictionaries/nl.json\").then((module) => module.default),\n};\nexport const getDictionary = async (locale) => dictionaries[locale]();\nการเลือกภาษาแบบนี้เราสามารถทำการ fetch dictionary ข้างใน layout หรือ page ได้\nimport { getDictionary } from \"./dictionaries\";\nexport default async function Page({ params: { lang } }) {\n  const dict = await getDictionary(lang); // en\n  return <button>{dict.products.cart}</button>; // Add to Cart\n}\nเพราะว่า layouts และ pages ทั้งหมดอยู่ข้างในapp/ directory ซึ่งค่าเริ่มต้นกำหนดเป็น Server Components เราจึงไม่ต้องกังวลเกี่ยวกับขนาดของไฟล์ที่จะมีผลกระทบต่อขนาดของ JavaScript ใน client-side เพราะว่า code เหล่านี้จะ ทำงานทางฝั่ง server เท่านั้น และส่งเฉพาะ HTML มาให้ browser.","static-generation#Static Generation":"ในการสร้าง static routes สำหรับภาษาที่กำหนดไว้ เราสามารถใช้ generateStaticParams กับ page หรือ layout ใดๆก็ได้ ซึ่งสามารถทำให้เป็น global ได้ใน root layout ตามตัวอย่าง:\nexport async function generateStaticParams() {\n  return [{ lang: \"en-US\" }, { lang: \"de\" }];\n}\nexport default function Root({ children, params }) {\n  return (\n    <html lang={params.lang}>\n      <body>{children}</body>\n    </html>\n  );\n}","resources#Resources":"Minimal i18n routing and translations\nnext-intl\nnext-international\nnext-i18n-router"}},"/Next.js/02-data-fetching/02-01-fetching-caching-and-revalidating":{"title":"Data Fetching, Caching, and Revalidating","data":{"":"Data fetching หรือการดึงข้อมูล เป็นส่วนสำคัญของทุกๆแอปพลิเคชัน ในบทนี้จะอธิบายถึงวิธีการ ดึงข้อมูล(fetch data) การจัดเก็บข้อมูลในแคช(cache) และการตรวจสอบความถูกต้องของข้อมูล (revalidate data) ใน React and Next.js.การดึงข้อมูลมีทั้งหมด 4 วิธี คือ\nบน server ด้วยการใช้ fetch\nบน server ด้วยการใช้ libraries ภายนอก\nบน client ผ่าน Route Handler\nบน client ด้วย libraries ภายนอก","fetching-data-on-the-server-with-fetch#Fetching Data on the Server with fetch":"การดึงข้อมูลบน server ด้วยการใช้ fetchNext.js เราสามารถกำหนดการทำงานของ fetch Web API เพื่อกำหนดวิธีการเก็บข้อมูลใน caching และ revalidating สำหรับการทำ fetch request แต่ละครั้งบน server แต่ใน React เมื่อ fetch ได้ทำการ request จะทำการเก็บข้อมูลโดยอัตโนมัติ memoize ระหว่างการ render โครงสร้างของ React componentเราสามารถใช้ fetch ร่วมกับ async/await ใน Server Components ใน Route Handlers และใน Server Actions ได้ตัวอย่าง เช่น\nasync function getData() {\n  const res = await fetch(\"https://api.example.com/...\");\n  // The return value is *not* serialized\n  // You can return Date, Map, Set, etc.\n  if (!res.ok) {\n    // This will activate the closest `error.js` Error Boundary\n    throw new Error(\"Failed to fetch data\");\n  }\n  return res.json();\n}\nexport default async function Page() {\n  const data = await getData();\n  return <main></main>;\n}\nasync function getData() {\n  const res = await fetch(\"https://api.example.com/...\");\n  // The return value is *not* serialized\n  // You can return Date, Map, Set, etc.\n  if (!res.ok) {\n    // This will activate the closest `error.js` Error Boundary\n    throw new Error(\"Failed to fetch data\");\n  }\n  return res.json();\n}\nexport default async function Page() {\n  const data = await getData();\n  return <main></main>;\n}\nสิ่งที่ควรรู้:\nNext.js มีฟังก์ชันในการทำงานที่มีประโยชน์เมื่อเรา fetching data ใน Server Components เช่น cookies และ headers ซึ่งทำให้สามารถ render dynamic route ได้\nใน Route handlers การทำ fetch requests จะไม่ถูกเก็บค่าไว้ในหน่วยความจำเนื่องจาก Router handlers ไม่ได้เป็นส่วนหนึ่งของ Component tree\nการใช้ async/await ใน Server Component แบบ TypeScript จะสามารถใช้ได้ใน TypeScript 5.1.3 หรือสูงกว่า และ @types/react 18.2.8 หรือสูงกว่า","caching-data#Caching Data":"การทำ Caching เพื่อเก็บข้อมูล ทำให้เราไม่ต้องดึงข้อมูลใหม่จากแหล่งข้อมูลในทุกครั้งที่มีคำขอเข้ามาค่าเริ่มต้นของ Next.js จะทำการ caches เก็บข้อมูลโดยอัตโนมัติ เมื่อมีการ fetch ใน Data Cache บน server นั่นคือเราสามารถดึงข้อมูลขณะ build time หรือ request time เพื่อเก็บไว้ใน cached และนำข้อมูลนั้นมาใช้ซ้ำเมื่อมีการ request เข้ามา\n// 'force-cache' is the default, and can be omitted\nfetch(\"https://...\", { cache: \"force-cache\" });\nfetch requests ที่ใช้ method POST ก็จะถูกเก็บไว้โดยอัตโนมัติด้วยเช่นกัน ยกเว้นว่ามันอยู่ใน Route Handler ที่ใช้ method POST จะไม่ถูกเก็บแคชเก็บไว้\nWhat is the Data Cache?The Data Cache is a persistent HTTP cache ขนาดของ cache สามารถปรับขนาดได้อัตโนมัติ และสามารถ shared ให้ส่วนต่างๆได้ ขึ้นอยู่กับแต่ละ platformเรียนรู้เพิ่มเติมได้ที่ Data Cache.","revalidating-data#Revalidating Data":"Revalidation คือกระบวนการ update ข้อมูล โดยจะล้างข้อมูลใน Cache และทำการดึงข้อมูลล่าสุดเข้ามาใหม่ (re-fetching) การทำแบบนี้มีประโยชน์เมื่อข้อมูลของเรามีการเปลี่ยนแปลงและเราต้องการให้แสดงข้อมูลที่อัพเดทสุดท้ายออกมาการทำ revalidated มีอยู่ 2 แนวทาง คือ\nTime-based revalidation: จะทำการตรวจสอบข้อมูลตามช่วงเวลาที่กำหนดไว้ เหมาะสำหรับข้อมูลที่มีการเปลี่ยนแปลงน้อย\nOn-demand revalidation: อยู่บนพื้นฐานการตรวจสอบข้อมูลแบบ Manually จะมีการตรวจสอบข้อมูลใหม่เมื่อมีเหตุการณ์ที่กำหนดไว้เกิดขึ้น เช่น การส่งฟอร์ม การทำ validation แบบ On-demand นี้ เราสามารถทำการ revalidate กลุ่มของข้อมูลที่เกี่ยวข้องกับ tag-based หรือ path-based นั้นๆได้ในครั้งเดียวกัน เหมาะสำหรับข้อมูลที่มีความต้องการให้แสดงทันทีหลังจากมีเหตุการณ์ที่กำหนดเกิดขึ้น เช่น การอัพเดทเนื้อหาจากระบบ CMS","time-based-revalidation#Time-based Revalidation":"เราสามารถกำหนดช่วงเวลาในการทำ revalidate ได้โดยใช้ next.revalidate ซึ่งเป็นตัวเลือกหนึ่งในการทำ fetch โดยมีหน่วยเวลาเป็นวินาที\nfetch(\"https://...\", { next: { revalidate: 3600 } });\nหากเราต้องการทำ revalidate ของ fetch requests ทั้งหมดใน route segment เราสามารถใช้ Segment Config Options ได้\nexport const revalidate = 3600; // revalidate at most every hour\nถ้าเราต้องการทำ fetch requests หลายๆอันใน statically rendered route และแต่ละอันมีความถี่ในการตรวจสอบข้อมูลต่างกัน เราจะใช้ช่วงเวลาที่น้อยที่สุดเป็นเวลาที่ใช้กำหนดการ request สำหรับ request ทั้งหมด แต่สำหรับ dynamic routes เราจะกำหนดให้การ fetch request แต่ละอันแยกออกจากกันเรียนรู้ข้อมูลเพิ่มเติมได้ที่ time-based revalidation.","on-demand-revalidation#On-demand Revalidation":"เราสามารถทำ revalidated on-demand ด้วย path (revalidatePath) หรือด้วย cache tag (revalidateTag) ใน Server Action or Route Handler ได้ ดังนี้ใน Next.js มีระบบ cache tagging สำหรับทำ invalidating fetch requests ข้าม routes ได้\nเมื่อเราใช้ fetch เรามีตัวเลือกสำหรับการทำ tag cache entries จำนวน 1 tag หรือมากกว่า\nหลังจากนั้นเราสามารถเรียกใช้ revalidateTag เพื่อดึงข้อมูลทั้งหมดที่เกี่ยวข้องมาให้ update ใหม่อีกครั้ง\nตัวอย่างโค้ดข้างล่าง เราจะใช้ fetch request เพื่อดึงข้อมูลของ tag ที่ชื่อว่า collection\nexport default async function Page() {\n  const res = await fetch(\"https://...\", { next: { tags: [\"collection\"] } });\n  const data = await res.json();\n  // ...\n}\nexport default async function Page() {\n  const res = await fetch(\"https://...\", { next: { tags: [\"collection\"] } });\n  const data = await res.json();\n  // ...\n}\nเราสามารถ revalidate ข้อมูลของ tag collection ของการ fetch ด้วยการใช้ revalidateTag ใน Server Action:\n\"use server\";\nimport { revalidateTag } from \"next/cache\";\nexport default async function action() {\n  revalidateTag(\"collection\");\n}\n\"use server\";\nimport { revalidateTag } from \"next/cache\";\nexport default async function action() {\n  revalidateTag(\"collection\");\n}\nเรียนรู้เพิ่มเติมเกี่ยวกับ on-demand revalidation.","error-handling-and-revalidation#Error handling and revalidation":"ถ้าเกิดข้อผิดพลาดขึ้นระหว่างการ validate ข้อมูล ระบบจะนำข้อมูลล่าสุดที่เก็บไว้ใน cache ก่อนที่จะเกิด error มาให้ใช้ และเมื่อมีการทำ validation อีกครั้ง ก็จะทำการดึงข้อมูลใหม่","opting-out-of-data-caching#Opting out of Data Caching":"หากเกิดเหตุการณ์ในกรณีต่อไปนี้ข้อมูลที่เกิดจากการทำ fetch requests จะไม่ถูกเก็บไว้ใน cached :\nตั้งค่าเป็น cache: 'no-store' สำหรัรบการทำ fetch requests\nตั้งค่าเป็น revalidate: 0 เมื่อทำการ fetch requests แต่ละรอบ\nทำ fetch request ใน Router Handler เมื่อใช้ POST method\nทำ fetch request หลังจากใช้ headers or cookies\nตั้งค่าเป็น const dynamic = 'force-dynamic' ใน route segment\nค่าเริ่มต้นของ fetchCache route segment ถูกตั้งค่าให้ไม่มีการเก็บ cache\nการทำ fetch request ที่ใช้ Authorization หรือ Cookie headers จะไม่มีการทำ cache ใน component tree","individual-fetch-requests#Individual fetch Requests":"หากเราไม่ต้องการให้เก็บ cache ในการ fetch แต่ละครั้ง เราสามารถตั้งค่า cache ใน fetch ให้เป็น 'no-store' การทำแบบนี้จะเป็นการดึงข้อมูลแบบ dynamic\nfetch(\"https://...\", { cache: \"no-store\" });\nสามารถดูตัวเลื่อกที่มีไว้สำหรับตั้งค่า cache ใน fetch API reference.","multiple-fetch-requests#Multiple fetch Requests":"ถ้าเราต้องการทำ fetch requests หลายๆอันใน route segment (เช่น ใน Layout or Page) เราสามาตั้งค่าการทำงานของ cache ในการดึงข้อมูลทั้งหมดที่มีอยู่ใน segment โดยใช้ Segment Config Options.แต่เราก็แนะนำให้ตั้งค่าที่ต้องการของ fetch request แต่ละอัน เพื่อให้สามารถควบคุมได้ดีมากขึ้น","fetching-data-on-the-server-with-third-party-libraries#Fetching data on the Server with third-party libraries":"ในกรณีที่คุณใช้ไลบรารีจากภายนอกที่ไม่รองรับการทำงานของฟังก์ชัน fetch (ตัวอย่างเช่นฐานข้อมูล, CMS, หรือ ORM client) คุณสามารถกำหนดการทำงานของแคชและการ revalidating ของ request เหล่านั้นได้ โดยใช้ Route Segment Config Option และฟังก์ชัน cache ของ Reactการที่ข้อมูลจะถูกแคชหรือไม่นั้น ขึ้นอยู่กับว่า route segment ของเราเป็นแบบ statically หรือ dynamically rendered\nหากเป็นแบบ static (ซึ่งเป็นค่าเริ่มต้น) ข้อมูลจะถูกเก็บไว้โดย cache และ ทำ validate ในส่วนของ route segment นั้น แต่ ถ้าหากว่าเป็นแบบ dynamic ข้อมูลจะไม่ถูกทำ cache เก็บไว้ และจะทำการดึงข้อมูลใหม่ทุกครั้งที่มีการ request และ render segment นั้นคุณสามารถทดลองใช้ฟังก์ชัน unstable_cache API ซึ่งอยู่ระหว่างการทดลองได้","example#Example":"ตัวอย่างการใช้งานในตัวอย่างข้างล่าง:\nฟังก์ชัน cache ใน React จะถูกใช้เพื่อทำ memoize ให้กับข้อมูลที่ดึงมา\nเราจะตั้งค่า revalidate ให้เท่ากับ 3600 ใน Layout และ Page segments หมายความว่า ข้อมุลจะถูก cache เก็บไว้ และ ทำการ revalidation ทุกหนึ่งชั่วโมง\nimport { cache } from \"react\";\nexport const getItem = cache(async (id: string) => {\n  const item = await db.item.findUnique({ id });\n  return item;\n});\nimport { cache } from \"react\";\nexport const getItem = cache(async (id) => {\n  const item = await db.item.findUnique({ id });\n  return item;\n});\nถึงแม้ว่าฟังก์ชัน getItem จะถูกเรียก 2 ครั้ง แต่จะมีการดึงข้อมูลจากฐานข้อมูลเพียงครั้งเดียวเท่านั้น\nimport { getItem } from \"@/utils/get-item\";\nexport const revalidate = 3600; // revalidate the data at most every hour\nexport default async function Layout({\n  params: { id },\n}: {\n  params: { id: string };\n}) {\n  const item = await getItem(id);\n  // ...\n}\nimport { getItem } from \"@/utils/get-item\";\nexport const revalidate = 3600; // revalidate the data at most every hour\nexport default async function Layout({ params: { id } }) {\n  const item = await getItem(id);\n  // ...\n}\nimport { getItem } from \"@/utils/get-item\";\nexport const revalidate = 3600; // revalidate the data at most every hour\nexport default async function Page({\n  params: { id },\n}: {\n  params: { id: string };\n}) {\n  const item = await getItem(id);\n  // ...\n}\nimport { getItem } from \"@/utils/get-item\";\nexport const revalidate = 3600; // revalidate the data at most every hour\nexport default async function Page({ params: { id } }) {\n  const item = await getItem(id);\n  // ...\n}","fetching-data-on-the-client-with-route-handlers#Fetching Data on the Client with Route Handlers":"การดึงข้อมูลบน client ด้วย Route Handlersถ้าคุณต้องการดึงข้อมูลใน component บน client คุณสามารถเรียกใช้\nRoute Handler จาก client ได้ ตัว Route Handlers จะทำงานในฝั่ง server และส่งข้อมูลคืนไปให้ฝั่งทาง client ประโยชน์ของวิธีนี้คือ จะไม่เปิดเผยข้อมูลสำคัญ เช่น API tokens ให้คนอื่นในฝั่ง client เห็นดูข้อมูลเพิ่มเติมได้ที่ Route Handler\nServer Components and Route Handlersหาก Server Components ทำการ render บน server คุณไม่จำเป็นต้องเรียก Route Handler จาก Server Component เพื่อดึงข้อมูล เพราะคุณสามารถดึงข้อมูลโดยตรงภายใน Server Component ได้เลย","fetching-data-on-the-client-with-third-party-libraries#Fetching Data on the Client with third-party libraries":"การดึงข้อมูลบน client ด้วย libraries ภายนอกเราสามารถดึงข้อมูลบน client ด้วย libraries ภายนอกได้ เช่น SWR หรือ TanStack Query libraries เหล่านี้จะมี APIs ของตัวเองสำหรับการทำ memoizing requests / caching / revalidating และ mutating data\nFuture APIs:use เป็นฟังก์ชันหนึ่งของ React ทำหน้าที่รับและจัดการกับ promise ที่ส่งข้อมูลกลับมาจากฟังก์ชัน ไม่แนะนำให้ใช้ใช้ use ครอบ fetch ใน Client Components เพราะอาจจะทำให้เกิดการ render ซ้ำซ้อนหลายครั้ง\nสามารถเรียนรู้เพิ่มเติมการใช้ use ได้ใน React docs."}},"/Next.js/02-data-fetching/02-02-server-actions-and-mutations":{"title":"Server Actions and Mutations","data":{"":"Server Actions คือ asynchronous functions ที่ทำงานบนฝั่ง server มันสามารถถูกใช้ได้ทั้งใน Server และ Client Components เพื่อจัดการการทำงานของ form submissions และ data mutations ใน Next.js\n🎥 Watch: เรียนรู้เพิ่มเติมเกี่ยวกับการทำงานของ forms และ mutations ด้วย Server Actions → YouTube (10 minutes).","convention#Convention":"เราสามารถกำหนด Server Action ใน React ด้วยการระบุ \"use server\" เราสามารถวาง \"use server\" ก่อนฟังก์ชัน async เพื่อกำหนดให้เป็นฟังก์ชันทำงานแบบ Server Action หรือ วาง \"use server\" ไว้บนสุดของไฟล์ เพื่อกำหนดให้การ export ของไฟล์นั้นทำงานแบบ Server Actions.","server-components#Server Components":"เราสามารถใช้ Server Components แบบ inline function level หรือ module level ได้โดยการใส่คำว่า \"use server\" ไว้ที่บรรทัดแรกของฟังก์ชันนั้น ดูตามตัวอย่างข้างล่าง :\n// Server Component\nexport default function Page() {\n  // Server Action\n  async function create() {\n    'use server'\n    // ...\n  }\n  return (\n    // ...\n  )\n}\n// Server Component\nexport default function Page() {\n  // Server Action\n  async function create() {\n    'use server'\n    // ...\n  }\n  return (\n    // ...\n  )\n}","client-components#Client Components":"Client Components สามารถนำเข้า actions ที่ระบุในระดับโมดูลว่าเป็น \"use server\"ในการเรียกใช้ Server Action ใน Client Component จะต้องสร้างไฟล์ใหม่และใส่คำว่า \"use server\" ที่บรรทัดแรกของไฟล์ การทำแบบนี้จะทำให้ฟังก์ชันทั้งหมดในไฟล์นั้นถูกระบุให้ทำงานแบบ Server Actions ซึ่งการทำแบบนี้จะทำให้เราสามารถเรียกใช้ฟังก์ชันเหล่านี้ได้ทั้งในส่วนของ Client และ Server Components:\n\"use server\";\nexport async function create() {\n  // ...\n}\n\"use server\";\nexport async function create() {\n  // ...\n}\nimport { create } from '@/app/actions'\nexport function Button() {\n  return (\n    // ...\n  )\n}\nimport { create } from '@/app/actions'\nexport function Button() {\n  return (\n    // ...\n  )\n}\nเราสามารถส่ง Server Action ไปให้ Client Component ได้โดยใช้ prop:\n<ClientComponent updateItem={updateItem} />\n\"use client\";\nexport default function ClientComponent({ updateItem }) {\n  return <form action={updateItem}>{/* ... */}</form>;\n}","behavior#Behavior":"การทำงานของ Server actions สามารถถูกเรียกใช้ได้โดยใช้ attribue action ใน <form> element:\nค่าเริ่มต้นของ Server Components รองรับการทำงานแบบ progressive enhancement หมายความว่า form จะถูกส่งข้อมูลไปแม้ว่า JavaScript จะยังไม่ถูกโหลดเข้าไปหรือมีการปิดใช้งาน JavaScript ก็ตาม\nใน Client Components นั้น forms จะถูก Server Actions จัดลำดับการเรียก แม้ว่ายังไม่ได้ JavaScript ก็ตาม prioritizing client hydration.\nหลังจากกระบวนการ hydration ตัว browse จะไม่ทำการ refresh เมื่อมีการส่งแบบฟอร์ม\nServer Actions ไม่ได้จำกัดเฉพาะการทำงานกับ <form> เท่านั้น แต่สามารถใช้กับ useEffect หรือ ไลบรารีภายนอกและ elements อื่นๆ อย่างเช่น <button>ด้วย\nServer Actions จะทำงานร่วมกับ caching and revalidation ของ Next.js เมื่อถูกเรียกใช้ให้ทำงานมันจะสามารถคืนค่า UI ที่อัพเดทแล้ว และ ข้อมูลใหม่ ในครั้งเดียวกัน\nเบื้องหลังการทำงานนี้ คือการใช้ POST method ทำงาน และวิธีนี้ใช้ได้กับการเรียกใช้แบบ HTTP method เท่านั้น\narguments และค่า return ของ Server Actions จะเป็นไปตามลำดับการทำงานของ React ดูข้อมูลเพิ่มเติมได้ที่ serializable arguments and values.\nServer Actions เป็นฟังก์ชัน หมายความว่า เราสามารถนำไปใช้ซ้ำได้ในส่วนต่างๆของแอปพลิเคชัน\nServer Actions จะได้รับการสืบทอดใน runtime จาก page หรือ layout ที่ถูกนำไปใช้","examples#Examples":"","forms#Forms":"React extends the HTML <form> element to allow Server Actions to be invoked with the action prop.When invoked in a form, the action automatically receives the FormData object. You don't need to use React useState to manage fields, instead, you can extract the data using the native FormData methods:\nexport default function Page() {\n  async function createInvoice(formData: FormData) {\n    \"use server\";\n    const rawFormData = {\n      customerId: formData.get(\"customerId\"),\n      amount: formData.get(\"amount\"),\n      status: formData.get(\"status\"),\n    };\n    // mutate data\n    // revalidate cache\n  }\n  return <form action={createInvoice}>...</form>;\n}\nexport default function Page() {\n  async function createInvoice(formData) {\n    \"use server\";\n    const rawFormData = {\n      customerId: formData.get(\"customerId\"),\n      amount: formData.get(\"amount\"),\n      status: formData.get(\"status\"),\n    };\n    // mutate data\n    // revalidate cache\n  }\n  return <form action={createInvoice}>...</form>;\n}\nGood to know:\nExample: Form with Loading & Error States\nWhen working with forms that have many fields, you may want to consider using the entries() method with JavaScript's Object.fromEntries(). For example: const rawFormData = Object.fromEntries(formData.entries())\nSee React <form> documentation to learn more.","passing-additional-arguments#Passing Additional Arguments":"You can pass additional arguments to a Server Action using the JavaScript bind method.\n\"use client\";\nimport { updateUser } from \"./actions\";\nexport function UserProfile({ userId }: { userId: string }) {\n  const updateUserWithId = updateUser.bind(null, userId);\n  return (\n    <form action={updateUserWithId}>\n      <input type=\"text\" name=\"name\" />\n      <button type=\"submit\">Update User Name</button>\n    </form>\n  );\n}\n\"use client\";\nimport { updateUser } from \"./actions\";\nexport function UserProfile({ userId }) {\n  const updateUserWithId = updateUser.bind(null, userId);\n  return (\n    <form action={updateUserWithId}>\n      <input type=\"text\" name=\"name\" />\n      <button type=\"submit\">Update User Name</button>\n    </form>\n  );\n}\nThe Server Action will receive the userId argument, in addition to the form data:\n\"use server\";\nexport async function updateUser(userId, formData) {\n  // ...\n}\nGood to know:\nAn alternative is to pass arguments as hidden input fields in the form (e.g. <input type=\"hidden\" name=\"userId\" value={userId} />). However, the value will be part of the rendered HTML and will not be encoded.\n.bind works in both Server and Client Components. It also supports progressive enhancement.","pending-states#Pending states":"You can use the React useFormStatus hook to show a pending state while the form is being submitted.\nuseFormStatus returns the status for a specific <form>, so it must be defined as a child of the <form> element.\nuseFormStatus is a React hook and therefore must be used in a Client Component.\n\"use client\";\nimport { useFormStatus } from \"react-dom\";\nexport function SubmitButton() {\n  const { pending } = useFormStatus();\n  return (\n    <button type=\"submit\" aria-disabled={pending}>\n      Add\n    </button>\n  );\n}\n\"use client\";\nimport { useFormStatus } from \"react-dom\";\nexport function SubmitButton() {\n  const { pending } = useFormStatus();\n  return (\n    <button type=\"submit\" aria-disabled={pending}>\n      Add\n    </button>\n  );\n}\n<SubmitButton /> can then be nested in any form:\nimport { SubmitButton } from \"@/app/submit-button\";\nimport { createItem } from \"@/app/actions\";\n// Server Component\nexport default async function Home() {\n  return (\n    <form action={createItem}>\n      <input type=\"text\" name=\"field-name\" />\n      <SubmitButton />\n    </form>\n  );\n}\nimport { SubmitButton } from \"@/app/submit-button\";\nimport { createItem } from \"@/app/actions\";\n// Server Component\nexport default async function Home() {\n  return (\n    <form action={createItem}>\n      <input type=\"text\" name=\"field-name\" />\n      <SubmitButton />\n    </form>\n  );\n}","server-side-validation-and-error-handling#Server-side validation and error handling":"We recommend using HTML validation like required and type=\"email\" for basic client-side form validation.For more advanced server-side validation, you can use a library like zod to validate the form fields before mutating the data:\n\"use server\";\nimport { z } from \"zod\";\nconst schema = z.object({\n  email: z.string({\n    invalid_type_error: \"Invalid Email\",\n  }),\n});\nexport default async function createUser(formData: FormData) {\n  const validatedFields = schema.safeParse({\n    email: formData.get(\"email\"),\n  });\n  // Return early if the form data is invalid\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n    };\n  }\n  // Mutate data\n}\n\"use server\";\nimport { z } from \"zod\";\nconst schema = z.object({\n  email: z.string({\n    invalid_type_error: \"Invalid Email\",\n  }),\n});\nexport default async function createsUser(formData) {\n  const validatedFields = schema.safeParse({\n    email: formData.get(\"email\"),\n  });\n  // Return early if the form data is invalid\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n    };\n  }\n  // Mutate data\n}\nOnce the fields have been validated on the server, you can return a serializable object in your action and use the React useFormState hook to show a message to the user.\nBy passing the action to useFormState, the action's function signature changes to receive a new prevState or initialState parameter as its first argument.\nuseFormState is a React hook and therefore must be used in a Client Component.\n\"use server\";\nexport async function createUser(prevState: any, formData: FormData) {\n  // ...\n  return {\n    message: \"Please enter a valid email\",\n  };\n}\n\"use server\";\nexport async function createUser(prevState, formData) {\n  // ...\n  return {\n    message: \"Please enter a valid email\",\n  };\n}\nThen, you can pass your action to the useFormState hook and use the returned state to display an error message.\n\"use client\";\nimport { useFormState } from \"react-dom\";\nimport { createUser } from \"@/app/actions\";\nconst initialState = {\n  message: \"\",\n};\nexport function Signup() {\n  const [state, formAction] = useFormState(createUser, initialState);\n  return (\n    <form action={formAction}>\n      <label htmlFor=\"email\">Email</label>\n      <input type=\"text\" id=\"email\" name=\"email\" required />\n      {/* ... */}\n      <p aria-live=\"polite\" className=\"sr-only\">\n        {state?.message}\n      </p>\n      <button>Sign up</button>\n    </form>\n  );\n}\n\"use client\";\nimport { useFormState } from \"react-dom\";\nimport { createUser } from \"@/app/actions\";\nconst initialState = {\n  message: \"\",\n};\nexport function Signup() {\n  const [state, formAction] = useFormState(createUser, initialState);\n  return (\n    <form action={formAction}>\n      <label htmlFor=\"email\">Email</label>\n      <input type=\"text\" id=\"email\" name=\"email\" required />\n      {/* ... */}\n      <p aria-live=\"polite\" className=\"sr-only\">\n        {state?.message}\n      </p>\n      <button>Sign up</button>\n    </form>\n  );\n}\nGood to know:\nBefore mutating data, you should always ensure a user is also authorized to perform the action. See Authentication and Authorization.","optimistic-updates#Optimistic updates":"You can use the React useOptimistic hook to optimistically update the UI before the Server Action finishes, rather than waiting for the response:\n\"use client\";\nimport { useOptimistic } from \"react\";\nimport { send } from \"./actions\";\ntype Message = {\n  message: string;\n};\nexport function Thread({ messages }: { messages: Message[] }) {\n  const [optimisticMessages, addOptimisticMessage] = useOptimistic<Message[]>(\n    messages,\n    (state: Message[], newMessage: string) => [\n      ...state,\n      { message: newMessage },\n    ]\n  );\n  return (\n    <div>\n      {optimisticMessages.map((m, k) => (\n        <div key={k}>{m.message}</div>\n      ))}\n      <form\n        action={async (formData: FormData) => {\n          const message = formData.get(\"message\");\n          addOptimisticMessage(message);\n          await send(message);\n        }}\n      >\n        <input type=\"text\" name=\"message\" />\n        <button type=\"submit\">Send</button>\n      </form>\n    </div>\n  );\n}\n\"use client\";\nimport { useOptimistic } from \"react\";\nimport { send } from \"./actions\";\nexport function Thread({ messages }) {\n  const [optimisticMessages, addOptimisticMessage] = useOptimistic(\n    messages,\n    (state, newMessage) => [...state, { message: newMessage }]\n  );\n  return (\n    <div>\n      {optimisticMessages.map((m) => (\n        <div>{m.message}</div>\n      ))}\n      <form\n        action={async (formData) => {\n          const message = formData.get(\"message\");\n          addOptimisticMessage(message);\n          await send(message);\n        }}\n      >\n        <input type=\"text\" name=\"message\" />\n        <button type=\"submit\">Send</button>\n      </form>\n    </div>\n  );\n}","nested-elements#Nested elements":"You can invoke a Server Action in elements nested inside <form> such as <button>, <input type=\"submit\">, and <input type=\"image\">. These elements accept the formAction prop or event handlers.This is useful in cases where you want to call multiple server actions within a form. For example, you can create a specific <button> element for saving a post draft in addition to publishing it. See the React <form> docs for more information.","programmatic-form-submission#Programmatic form submission":"You can trigger a form submission using the requestSubmit() method. For example, when the user presses ⌘ + Enter, you can listen for the onKeyDown event:\n\"use client\";\nexport function Entry() {\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (\n      (e.ctrlKey || e.metaKey) &&\n      (e.key === \"Enter\" || e.key === \"NumpadEnter\")\n    ) {\n      e.preventDefault();\n      e.currentTarget.form?.requestSubmit();\n    }\n  };\n  return (\n    <div>\n      <textarea name=\"entry\" rows={20} required onKeyDown={handleKeyDown} />\n    </div>\n  );\n}\n\"use client\";\nexport function Entry() {\n  const handleKeyDown = (e) => {\n    if (\n      (e.ctrlKey || e.metaKey) &&\n      (e.key === \"Enter\" || e.key === \"NumpadEnter\")\n    ) {\n      e.preventDefault();\n      e.currentTarget.form?.requestSubmit();\n    }\n  };\n  return (\n    <div>\n      <textarea name=\"entry\" rows={20} required onKeyDown={handleKeyDown} />\n    </div>\n  );\n}\nThis will trigger the submission of the nearest <form> ancestor, which will invoke the Server Action.","non-form-elements#Non-form Elements":"While it's common to use Server Actions within <form> elements, they can also be invoked from other parts of your code such as event handlers and useEffect.","event-handlers#Event Handlers":"You can invoke a Server Action from event handlers such as onClick. For example, to increment a like count:\n\"use server\";\nexport async function incrementLike() {\n  // Mutate database\n  // Return updated data\n}\n\"use client\";\nimport { incrementLike } from \"./actions\";\nimport { useState } from \"react\";\nexport default function LikeButton({ initialLikes }: { initialLikes: number }) {\n  const [likes, setLikes] = useState(initialLikes);\n  return (\n    <>\n      <p>Total Likes: {likes}</p>\n      <button\n        onClick={async () => {\n          const updatedLikes = await incrementLike();\n          setLikes(updatedLikes);\n        }}\n      >\n        Like\n      </button>\n    </>\n  );\n}\nTo improve the user experience, we recommend using other React APIs like useOptimistic and useTransition to update the UI before the Server Action finishes executing on the server, or to show a pending state.You can also add event handlers to form elements, for example, to save a form field onChange:\n\"use client\";\nimport { publishPost, saveDraft } from \"./actions\";\nexport default function EditPost() {\n  return (\n    <form action={publishPost}>\n      <textarea\n        name=\"content\"\n        onChange={async (e) => {\n          await saveDraft(e.target.value);\n        }}\n      />\n      <button type=\"submit\">Publish</button>\n    </form>\n  );\n}\nFor cases like this, where multiple events might be fired in quick succession, we recommend debouncing to prevent unnecessary Server Action invocations.","useeffect#useEffect":"You can use the React useEffect hook to invoke a Server Action when the component mounts or a dependency changes. This is useful for mutations that depend on global events or need to be triggered automatically. For example, onKeyDown for app shortcuts, an intersection observer hook for infinite scrolling, or when the component mounts to update a view count:\n\"use client\";\nimport { incrementViews } from \"./actions\";\nimport { useState, useEffect } from \"react\";\nexport default function ViewCount({ initialViews }: { initialViews: number }) {\n  const [views, setViews] = useState(initialViews);\n  useEffect(() => {\n    const updateViews = async () => {\n      const updatedViews = await incrementViews();\n      setViews(updatedViews);\n    };\n    updateViews();\n  }, []);\n  return <p>Total Views: {views}</p>;\n}\nRemember to consider the behavior and caveats of useEffect.","error-handling#Error Handling":"When an error is thrown, it'll be caught by the nearest error.js or <Suspense> boundary on the client. We recommend using try/catch to return errors to be handled by your UI.For example, your Server Action might handle errors from creating a new item by returning a message:\n\"use server\";\nexport async function createTodo(prevState: any, formData: FormData) {\n  try {\n    // Mutate data\n  } catch (e) {\n    throw new Error(\"Failed to create task\");\n  }\n}\n\"use server\";\nexport async function createTodo(prevState, formData) {\n  try {\n    //  Mutate data\n  } catch (e) {\n    throw new Error(\"Failed to create task\");\n  }\n}\nGood to know:\nAside from throwing the error, you can also return an object to be handled by useFormState. See Server-side validation and error handling.","revalidating-data#Revalidating data":"You can revalidate the Next.js Cache inside your Server Actions with the revalidatePath API:\n\"use server\";\nimport { revalidatePath } from \"next/cache\";\nexport async function createPost() {\n  try {\n    // ...\n  } catch (error) {\n    // ...\n  }\n  revalidatePath(\"/posts\");\n}\n\"use server\";\nimport { revalidatePath } from \"next/cache\";\nexport async function createPost() {\n  try {\n    // ...\n  } catch (error) {\n    // ...\n  }\n  revalidatePath(\"/posts\");\n}\nOr invalidate a specific data fetch with a cache tag using revalidateTag:\n\"use server\";\nimport { revalidateTag } from \"next/cache\";\nexport async function createPost() {\n  try {\n    // ...\n  } catch (error) {\n    // ...\n  }\n  revalidateTag(\"posts\");\n}\n\"use server\";\nimport { revalidateTag } from \"next/cache\";\nexport async function createPost() {\n  try {\n    // ...\n  } catch (error) {\n    // ...\n  }\n  revalidateTag(\"posts\");\n}","redirecting#Redirecting":"If you would like to redirect the user to a different route after the completion of a Server Action, you can use redirect API. redirect needs to be called outside of the try/catch block:\n\"use server\";\nimport { redirect } from \"next/navigation\";\nimport { revalidateTag } from \"next/cache\";\nexport async function createPost(id: string) {\n  try {\n    // ...\n  } catch (error) {\n    // ...\n  }\n  revalidateTag(\"posts\"); // Update cached posts\n  redirect(`/post/${id}`); // Navigate to the new post page\n}\n\"use server\";\nimport { redirect } from \"next/navigation\";\nimport { revalidateTag } from \"next/cache\";\nexport async function createPost(id) {\n  try {\n    // ...\n  } catch (error) {\n    // ...\n  }\n  revalidateTag(\"posts\"); // Update cached posts\n  redirect(`/post/${id}`); // Navigate to the new post page\n}","cookies#Cookies":"You can get, set, and delete cookies inside a Server Action using the cookies API:\n\"use server\";\nimport { cookies } from \"next/headers\";\nexport async function exampleAction() {\n  // Get cookie\n  const value = cookies().get(\"name\")?.value;\n  // Set cookie\n  cookies().set(\"name\", \"Delba\");\n  // Delete cookie\n  cookies().delete(\"name\");\n}\n\"use server\";\nimport { cookies } from \"next/headers\";\nexport async function exampleAction() {\n  // Get cookie\n  const value = cookies().get(\"name\")?.value;\n  // Set cookie\n  cookies().set(\"name\", \"Delba\");\n  // Delete cookie\n  cookies().delete(\"name\");\n}\nSee additional examples for deleting cookies from Server Actions.","security#Security":"","authentication-and-authorization#Authentication and authorization":"You should treat Server Actions as you would public-facing API endpoints, and ensure that the user is authorized to perform the action. For example:\n\"use server\";\nimport { auth } from \"./lib\";\nexport function addItem() {\n  const { user } = auth();\n  if (!user) {\n    throw new Error(\"You must be signed in to perform this action\");\n  }\n  // ...\n}","closures-and-encryption#Closures and encryption":"Defining a Server Action inside a component creates a closure where the action has access to the outer function's scope. For example, the publish action has access to the publishVersion variable:\nexport default function Page() {\n  const publishVersion = await getLatestVersion();\n  async function publish(formData: FormData) {\n    \"use server\";\n    if (publishVersion !== await getLatestVersion()) {\n      throw new Error('The version has changed since pressing publish');\n    }\n    ...\n  }\n  return <button action={publish}>Publish</button>;\n}\nexport default function Page() {\n  const publishVersion = await getLatestVersion();\n  async function publish() {\n    \"use server\";\n    if (publishVersion !== await getLatestVersion()) {\n      throw new Error('The version has changed since pressing publish');\n    }\n    ...\n  }\n  return <button action={publish}>Publish</button>;\n}\nClosures are useful when you need to capture a snapshot of data (e.g. publishVersion) at the time of rendering so that it can be used later when the action is invoked.However, for this to happen, the captured variables are sent to the client and back to the server when the action is invoked. To prevent sensitive data from being exposed to the client, Next.js automatically encrypts the closed-over variables. A new private key is generated for each action every time a Next.js application is built. This means actions can only be invoked for a specific build.\nGood to know: We don't recommend relying on encryption alone to prevent sensitive values from being exposed on the client. Instead, you should use the React taint APIs to proactively prevent specific data from being sent to the client.","overwriting-encryption-keys-advanced#Overwriting encryption keys (advanced)":"When self-hosting your Next.js application across multiple servers, each server instance may end up with a different encryption key, leading to potential inconsistencies.To mitigate this, you can overwrite the encryption key using the process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY environment variable. Specifying this variable ensures that your encryption keys are persistent across builds, and all server instances use the same key.This is an advanced use case where consistent encryption behavior across multiple deployments is critical for your application. You should consider standard security practices such key rotation and signing.\nGood to know: Next.js applications deployed to Vercel automatically handle this.","allowed-origins-advanced#Allowed origins (advanced)":"Since Server Actions can be invoked in a <form> element, this opens them up to CSRF attacks.Behind the scenes, Server Actions use the POST method, and only this HTTP method is allowed to invoke them. This prevents most CSRF vulnerabilities in modern browsers, particularly with SameSite cookies being the default.As an additional protection, Server Actions in Next.js also compare the Origin header to the Host header (or X-Forwarded-Host). If these don't match, the request will be aborted. In other words, Server Actions can only be invoked on the same host as the page that hosts it.For large applications that use reverse proxies or multi-layered backend architectures (where the server API differs from the production domain), it's recommended to use the configuration option serverActions.allowedOrigins option to specify a list of safe origins. The option accepts an array of strings.\n/** @type {import('next').NextConfig} */\nmodule.exports = {\n  experimental: {\n    serverActions: {\n      allowedOrigins: [\"my-proxy.com\", \"*.my-proxy.com\"],\n    },\n  },\n};\nLearn more about Security and Server Actions.","additional-resources#Additional resources":"For more information on Server Actions, check out the following React docs:\n\"use server\"\n<form>\nuseFormStatus\nuseFormState\nuseOptimistic"}},"/Next.js/02-data-fetching/02-03-patterns":{"title":"Patterns and Best Practices","data":{"":"ในส่วนนี้จะกล่าวถึงวิธีการใช้งาน รูปแบบ และ best practices ในการดึงข้อมูล(fetch)ใน React และ Next.js","fetching-data-on-the-server#Fetching Data on the Server":"หากเป็นไปได้เราแนะนำคุณให้ทำการ fetching data บน server ด้วย Server Components ซึ่งจะช่่วยเราได้ ดังนี้:\nทำให้เราเข้าถึงข้อมูลที่อยู่ในระบบหลังบ้าน เช่น databases ได้โดยตรง\nแอปพลิเคชันของคุณจึงมีความปลอดภัยมากขึ้น\nสามารถป้องกันไม่ให้มีการเปิดเผยข้อมูลที่เป็นความลับ เช่น access tokens และ API keys ไปยังฝั่ง client\nการ Fetch data และ render ในสภาพแวดล้อมเดียวกัน เป็นการลด การส่งข้อมูลกลับไปกลับมาระหว่าง client กับ server รวมถึง การทำงานของ main thread บน client ด้วย\nสามารถทำการดึงข้อมูลหลายรายการได้ด้วยการส่งข้อมูลเพียงครั้งเดียว แทนที่จะส่งคำขอแต่ละรายการจากฝั่ง client\nลดการทำงานแบบ client-server waterfalls.\nหากมีการเก็บข้อมูลในหลายๆพื้นที่ การดึงข้อมูลในฝั่ง server ทำให้เราสามารถเลือกดึงข้อมูลในพื้นที่ที่ใกล้ที่สุดจากที่เก็บข้อมูลของคุณเป็นการลด latency และเพิ่ม performance\nดังนั้น เราสามารถ ทำงานกับข้อมูลและ update ข้อมูลด้วย Server Actions.","fetching-data-where-its-needed#Fetching Data Where It's Needed":"ถ้าคุณใช้ข้อมูลเดียวกันในหลายๆ component ใน tree คุณไม่จำเป็นต้องดึงข้อมูลแบบ Global หรือ ไม่ต้องส่ง props ข้าม component แต่คุณสามารถใช้ fetch หริอ cache ใน component ที่ต้องการข้อมูลนั้นๆ โดยไม่ต้องกังวลเรื่องผลกระทบทางประสิทธิภาพที่เกิดจากการ request หลายๆครั้งในข้อมูลตัวเดียวกันเราสามารถทำได้ในครั้งเดียว เพราะfetch จะเก็บข้อมูลไว้โดยอัตโนมัติ ดูเพิ่มเติมได้ในหัวข้อ request memoization\nสิ่งที่ควรรู้: การทำแบบนี้มีผลกับ layouts ด้วย เพราะเราไม่สามารถส่งข้อมูลระหว่าง parent layout กับ children ของ layout นั้น","streaming#Streaming":"Streaming และ Suspense เป็น features ของ React ที่ช่วยให้เราสามารถ render และ stream UI ของส่วนที่ทำการ rendered แล้ว ไปให้ฝั่ง clientในส่วนของ Server Components และ nested layouts เราสามารถแสดงส่วนของหน้าเว็บ โดยที่ไม่ต้องดึงข้อมูลเพิ่ม หรือ แสดงตัว loading state ในส่วนที่เราทำการ fetching data เพิ่ม หมายความว่า เราสามารถแสดงหน้าเว็บบางส่วนให้สามารถทำ interactive ได้โดยไม่ต้องรอให้ดึงข้อมูลทั้งหมดเสร็จก่อน\nเรียนรู้เพิ่มเติมเกี่ยวกับ Streaming และ Suspense ได้ที่ Loading UI และ Streaming and Suspense","parallel-and-sequential-data-fetching#Parallel and Sequential Data Fetching":"เมื่อเราดึงข้อมูลข้างใน component ของ React มีสิ่งที่ควรระวัง คือ fetching patterns: Parallel และ Sequential.\nการดึงข้อมูลแบบ sequential data fetching เป็นการดึงข้อมูลแบบตามลำดับก่อนหลัง ซึ่งจะดึงข้อมูลในลำดับก่อนหน้าให้เสร็จก่อนจึงจะสามารถดึงข้อมูลในส่วนถัดมาได้ เพราะเราต้องการใช้ข้อมูลก่อนหน้าสำหรับการทำงานในข้อมูลลำดับถัดมา เช่น อาจจะมีบางครั้งที่เราต้องการ กรองข้อมูลก่อนหน้าด้วยเงื่อนไขบางอย่าง สำหรับเป็นข้อมูลตั้งต้นในลำดับต่อไปเพื่อเป็นการประหยัดทรัพยากร เราเรียกการดึงข้อมูลแบบนี้ ว่า waterfalls แต่บางครั้งการดึงข้อมูลแบบนี้อาจเกิดขึ้นโดยไม่ได้ตั้งใจ ซึ่งทำให้ใช้เวลาในการโหลดข้อมูลนานขึ้น\nการดึงข้อมูลแบบขนาน หรือ parallel data fetching จะเป็นการร้องขอให้ดึงข้อมูลใน route เลยในช่วงเริ่มต้น ซึ่งจะสามารถลดการทำงานแบบ client-server waterfalls และ ลดเวลารวมในการ load data อีกด้วย","sequential-data-fetching#Sequential Data Fetching":"หากคุณมี components ที่ซ้อนกันอยู่ และในแต่ละ component ดึงข้อมูลของมันเอง การทำ data fetching นั้นจะเป็นการรดึงข้อมูลแบบ sequentially เกิดขึ้นถ้าคุณเรียกใช้ข้อมูลที่แตกต่างกัน (แต่จะไม่เกิดขึ้นในกรณีที่ดึงข้อมูลที่เหมือนกัน เพราะจะเกิดการทำ memoized โดยอัตโนมัติ)ตัวอย่าง เช่น component ชื่อว่า Playlists จะเริ่มต้นดึงข้อมูลเมื่อ component Artist ดึงข้อมูลเสร็จก่อน เพราะว่า Playlists จะต้องใช้ artistID จาก Playlists:\n// ...\nasync function Playlists({ artistID }: { artistID: string }) {\n  // Wait for the playlists\n  const playlists = await getArtistPlaylists(artistID);\n  return (\n    <ul>\n      {playlists.map((playlist) => (\n        <li key={playlist.id}>{playlist.name}</li>\n      ))}\n    </ul>\n  );\n}\nexport default async function Page({\n  params: { username },\n}: {\n  params: { username: string };\n}) {\n  // Wait for the artist\n  const artist = await getArtist(username);\n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Playlists artistID={artist.id} />\n      </Suspense>\n    </>\n  );\n}\n// ...\nasync function Playlists({ artistID }) {\n  // Wait for the playlists\n  const playlists = await getArtistPlaylists(artistID);\n  return (\n    <ul>\n      {playlists.map((playlist) => (\n        <li key={playlist.id}>{playlist.name}</li>\n      ))}\n    </ul>\n  );\n}\nexport default async function Page({ params: { username } }) {\n  // Wait for the artist\n  const artist = await getArtist(username);\n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Playlists artistID={artist.id} />\n      </Suspense>\n    </>\n  );\n}\nในกรณีแบบนี้ คุณสามารถใช้ loading.js (สำหรับ route segments) หรือ React <Suspense> (สำหรัรบการทำ nested components) เพื่อแสดงสถานะ loading เพื่อบอกผู้ใช้ให้รู้ว่าอยู่ระหว่างการนำเข้าผลลัพธ์การทำแบบนี้จะป้องกันไม่ให้การดึงข้อมูลถูก block ระหว่างการดึงข้อมูล และ ผู้ใช้สามารถ ใช้งานส่วนต่างๆในหน้านั้นได้\nBlocking Data Requests:\nBlocking data request เป็นวิธีหนึ่งในการป้องกันการดึงข้อมูลแบบ waterfalls ที่ root ของ application แต่จะปิดกั้นการ render ของ route segments ทั้งหมดจนกระทั่ง load ข้อมูลเสร็จ เรียกลักษณะการทำงานแบบนี้ว่าการดึงข้อมูลแบบ \"all or nothing\" นั่นคือ การทำงานนี้จะเกิดขึ้นไม่ว่าคุณจะมีข้อมูลสำหรับหน้าแอปพลิเคชันหรือไม่มีข้อมูลก็ตาม\nการทำ fetch requests ด้วย await จะปิดกั้นการ render และการดึงข้อมูลที่อยู่ภายใต้การ request นี้ แต่หากมีการใช้ <Suspense> หรือ loading.js จะทำให้สามารถดึงข้อมูลแบบ parallel data fetching หรือ preload pattern ได้","parallel-data-fetching#Parallel Data Fetching":"เพื่อให้เราสามารถดึงข้อมูลได้พร้อมๆกัน เราสามารถกำหนดการดึงข้อมูลนี้ให้อยู่นอก component ที่เราต้องการใช้ข้อมูล จากนั้นจึงเรียกใช้จากด้านใน component ที่เราจะใช้ข้อมูลนั้น การทำแบบนี้จะทำให้เราสามารถประหยัดเวลาได้ user จะยังไม่สามารถมองเห็นข้อมูลได้จนกว่าข้อมูลทั้งหมดจะทำงานเสร็จตัวอย่างโค้ดข้างล่างนี้ ฟังก์ชัน getArtist และ getArtistAlbums ถูกกำหนดไว้นอก component Page เมื่อเราเรียกใช้จากภายใน component เราจะต้องรอให้ทั้งสองฟังก์ชันทำงานเสร็จก่อน\nimport Albums from \"./albums\";\nasync function getArtist(username: string) {\n  const res = await fetch(`https://api.example.com/artist/${username}`);\n  return res.json();\n}\nasync function getArtistAlbums(username: string) {\n  const res = await fetch(`https://api.example.com/artist/${username}/albums`);\n  return res.json();\n}\nexport default async function Page({\n  params: { username },\n}: {\n  params: { username: string };\n}) {\n  // Initiate both requests in parallel\n  const artistData = getArtist(username);\n  const albumsData = getArtistAlbums(username);\n  // Wait for the promises to resolve\n  const [artist, albums] = await Promise.all([artistData, albumsData]);\n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Albums list={albums}></Albums>\n    </>\n  );\n}\nimport Albums from \"./albums\";\nasync function getArtist(username) {\n  const res = await fetch(`https://api.example.com/artist/${username}`);\n  return res.json();\n}\nasync function getArtistAlbums(username) {\n  const res = await fetch(`https://api.example.com/artist/${username}/albums`);\n  return res.json();\n}\nexport default async function Page({ params: { username } }) {\n  // Initiate both requests in parallel\n  const artistData = getArtist(username);\n  const albumsData = getArtistAlbums(username);\n  // Wait for the promises to resolve\n  const [artist, albums] = await Promise.all([artistData, albumsData]);\n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Albums list={albums}></Albums>\n    </>\n  );\n}\nเพื่อเป็นการสร้างประสบการ์การใช้งานที่ดีให้กับผู้ใช้งาน เราสามารถเพิ่มขอบเขตการรอ โดยเพิ่ม Suspense Boundary เพื่อแบ่งการ reander เป็นส่วนๆ และจะทำให้เราสามารถแสดงผลได้เร็วขึ้น","preloading-data#Preloading Data":"อีกวิธีหนึ่งในการป้องกันการทำงานแบบ waterfalls คือ การใช้ preload pattern เราสามารถสร้างฟังก์ชัน preload ขึ้นมา เพื่อทำให้การดึงข้อมูลเป็นแบบ parallel data fetching ด้วยการทำแบบนี้ เราไม่ต้องใช้ promises เพราะเราจะตั้งชื่อในการใช้หังก์ชัน preload ให้เป็นชื่อใดๆ ก็ได้เพราะว่ามันไม่ใช่ API.\nimport { getItem } from \"@/utils/get-item\";\nexport const preload = (id: string) => {\n  // void evaluates the given expression and returns undefined\n  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\n  void getItem(id);\n};\nexport default async function Item({ id }: { id: string }) {\n  const result = await getItem(id);\n  // ...\n}\nimport { getItem } from \"@/utils/get-item\";\nexport const preload = (id) => {\n  // void evaluates the given expression and returns undefined\n  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\n  void getItem(id);\n};\nexport default async function Item({ id }) {\n  const result = await getItem(id);\n  // ...\n}\nimport Item, { preload, checkIsAvailable } from \"@/components/Item\";\nexport default async function Page({\n  params: { id },\n}: {\n  params: { id: string };\n}) {\n  // starting loading item data\n  preload(id);\n  // perform another asynchronous task\n  const isAvailable = await checkIsAvailable();\n  return isAvailable ? <Item id={id} /> : null;\n}\nimport Item, { preload, checkIsAvailable } from \"@/components/Item\";\nexport default async function Page({ params: { id } }) {\n  // starting loading item data\n  preload(id);\n  // perform another asynchronous task\n  const isAvailable = await checkIsAvailable();\n  return isAvailable ? <Item id={id} /> : null;\n}","using-react-cache-server-only-and-the-preload-pattern#Using React cache, server-only, and the Preload Pattern":"เราสามารถรวมฟังก์ชัน cache preload pattern และ server-only package ในการสร้างเครื่องมือช่วยในการดึงข้อมูลสำหรับใช้ในแอฟพลิเคชันของเราได้\nimport { cache } from \"react\";\nimport \"server-only\";\nexport const preload = (id: string) => {\n  void getItem(id);\n};\nexport const getItem = cache(async (id: string) => {\n  // ...\n});\nimport { cache } from \"react\";\nimport \"server-only\";\nexport const preload = (id) => {\n  void getItem(id);\n};\nexport const getItem = cache(async (id) => {\n  // ...\n});\nด้วยการทำงานแบบนี้ เราสามารถดึงข้อมูลก่อน เกิดการทำงานของ cache และแน่นอน การดึงข้อมูลนี้เกิดขึ้นเฉพาะในฝั่ง server.ไฟล์ที่อยู่ในโฟลเดอร์ utils/get-item สามารถนำมาใช้ได้โดยการใช้ Layouts, Pages, หรือ components อื่นๆ เพื่อกำหนดการทำงานเมื่อมีการสั่งให้ดึงข้อมูล\nสิ่งที่ควรรู้:\nเราแนะนำให้ใช้ server-only package เพื่อให้แน่ใจว่าเราไม่ได้ดึงข้อมูลในฝั่ง client","preventing-sensitive-data-from-being-exposed-to-the-client#Preventing sensitive data from being exposed to the client":"การป้องกันการเปิดเผยข้อมูลที่ sensitive ออกสู่ฝั่ง clientเราแนะนำให้ใช้ React's taint APIs, taintObjectReference and taintUniqueValue เพื่อป้องกันการเข้าถึง object ทั้งหมด หรือ ข้อมูลที่ sensitive จากภายนอก เมื่อเราส่งข้อมูลไปให้ฝั่ง clientเราสามารถตั้งค่าใน Next.js Config experimental.taint ให้เป็นค่า true เพื่อเปิดให้ tainting ทำงาน:\nmodule.exports = {\n  experimental: {\n    taint: true,\n  },\n};\nหลังจากนั้นเราจะส่ง object หรือ value ที่เราต้องการทำ taint ให้กับฟังก์ชัน experimental_taintObjectReference หรือ experimental_taintUniqueValue :\nimport { queryDataFromDB } from \"./api\";\nimport {\n  experimental_taintObjectReference,\n  experimental_taintUniqueValue,\n} from \"react\";\nexport async function getUserData() {\n  const data = await queryDataFromDB();\n  experimental_taintObjectReference(\n    \"Do not pass the whole user object to the client\",\n    data\n  );\n  experimental_taintUniqueValue(\n    \"Do not pass the user's phone number to the client\",\n    data,\n    data.phoneNumber\n  );\n  return data;\n}\nimport { queryDataFromDB } from \"./api\";\nimport {\n  experimental_taintObjectReference,\n  experimental_taintUniqueValue,\n} from \"react\";\nexport async function getUserData() {\n  const data = await queryDataFromDB();\n  experimental_taintObjectReference(\n    \"Do not pass the whole user object to the client\",\n    data\n  );\n  experimental_taintUniqueValue(\n    \"Do not pass the user's phone number to the client\",\n    data,\n    data.phoneNumber\n  );\n  return data;\n}\nimport { getUserData } from \"./data\";\nexport async function Page() {\n  const userData = getUserData();\n  return (\n    <ClientComponent\n      user={userData} // this will cause an error because of taintObjectReference\n      phoneNumber={userData.phoneNumber} // this will cause an error because of taintUniqueValue\n    />\n  );\n}\nimport { getUserData } from \"./data\";\nexport async function Page() {\n  const userData = getUserData();\n  return (\n    <ClientComponent\n      user={userData} // this will cause an error because of taintObjectReference\n      phoneNumber={userData.phoneNumber} // this will cause an error because of taintUniqueValue\n    />\n  );\n}\nเรียนรู้เพิ่มเติมได้ที่ Security and Server Actions."}}}